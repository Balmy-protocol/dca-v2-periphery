{
  "language": "Solidity",
  "sources": {
    "contracts/DCAFeeManager/DCAFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/Multicall.sol';\nimport '../interfaces/IDCAFeeManager.sol';\n\ncontract DCAFeeManager is SwapAdapter, AccessControl, Multicall, IDCAFeeManager {\n  bytes32 public constant SUPER_ADMIN_ROLE = keccak256('SUPER_ADMIN_ROLE');\n  bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\n\n  using SafeERC20 for IERC20;\n  using Address for address payable;\n\n  /// @inheritdoc IDCAFeeManager\n  uint16 public constant MAX_TOKEN_TOTAL_SHARE = 10000;\n  /// @inheritdoc IDCAFeeManager\n  uint32 public constant SWAP_INTERVAL = 1 days;\n  /// @inheritdoc IDCAFeeManager\n  mapping(bytes32 => uint256) public positions; // key(from, to) => position id\n\n  mapping(address => uint256[]) internal _positionsWithToken; // token address => all positions with address as to\n\n  constructor(address _superAdmin, address[] memory _initialAdmins) SwapAdapter(address(1)) {\n    if (_superAdmin == address(0)) revert ZeroAddress();\n    // We are setting the super admin role as its own admin so we can transfer it\n    _setRoleAdmin(SUPER_ADMIN_ROLE, SUPER_ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, SUPER_ADMIN_ROLE);\n    _setupRole(SUPER_ADMIN_ROLE, _superAdmin);\n    for (uint256 i; i < _initialAdmins.length; i++) {\n      _setupRole(ADMIN_ROLE, _initialAdmins[i]);\n    }\n  }\n\n  /// @inheritdoc IDCAFeeManager\n  function runSwapsAndTransferMany(RunSwapsAndTransferManyParams calldata _parameters) public payable onlyRole(ADMIN_ROLE) {\n    // Approve whatever is necessary\n    for (uint256 i = 0; i < _parameters.allowanceTargets.length; ) {\n      Allowance memory _allowance = _parameters.allowanceTargets[i];\n      _maxApproveSpenderIfNeeded(_allowance.token, _allowance.allowanceTarget, _allowance.minAllowance);\n      unchecked {\n        i++;\n      }\n    }\n\n    // Execute swaps\n    for (uint256 i = 0; i < _parameters.swaps.length; ) {\n      SwapContext memory _context = _parameters.swapContext[i];\n      _executeSwap(_parameters.swappers[_context.swapperIndex], _parameters.swaps[i], _context.value);\n      unchecked {\n        i++;\n      }\n    }\n\n    // Transfer out whatever was left in the contract\n    for (uint256 i = 0; i < _parameters.transferOutBalance.length; ) {\n      TransferOutBalance memory _transferOutBalance = _parameters.transferOutBalance[i];\n      _sendBalanceOnContractToRecipient(_transferOutBalance.token, _transferOutBalance.recipient);\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /// @inheritdoc IDCAFeeManager\n  function withdrawFromPlatformBalance(\n    IDCAHub _hub,\n    IDCAHub.AmountOfToken[] calldata _amountToWithdraw,\n    address _recipient\n  ) external onlyRole(ADMIN_ROLE) {\n    _hub.withdrawFromPlatformBalance(_amountToWithdraw, _recipient);\n  }\n\n  /// @inheritdoc IDCAFeeManager\n  function withdrawFromBalance(IDCAHub.AmountOfToken[] calldata _amountToWithdraw, address _recipient) external onlyRole(ADMIN_ROLE) {\n    for (uint256 i = 0; i < _amountToWithdraw.length; ) {\n      IDCAHub.AmountOfToken memory _amountOfToken = _amountToWithdraw[i];\n      if (_amountOfToken.amount == type(uint256).max) {\n        _sendBalanceOnContractToRecipient(_amountOfToken.token, _recipient);\n      } else {\n        _sendToRecipient(_amountOfToken.token, _amountOfToken.amount, _recipient);\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /// @inheritdoc IDCAFeeManager\n  function withdrawFromPositions(\n    IDCAHub _hub,\n    IDCAHub.PositionSet[] calldata _positionSets,\n    address _recipient\n  ) external onlyRole(ADMIN_ROLE) {\n    _hub.withdrawSwappedMany(_positionSets, _recipient);\n  }\n\n  /// @inheritdoc IDCAFeeManager\n  function fillPositions(\n    IDCAHub _hub,\n    AmountToFill[] calldata _amounts,\n    TargetTokenShare[] calldata _distribution\n  ) external onlyRole(ADMIN_ROLE) {\n    for (uint256 i = 0; i < _amounts.length; ) {\n      AmountToFill memory _amount = _amounts[i];\n\n      _maxApproveSpenderIfNeeded(\n        IERC20(_amount.token),\n        address(_hub),\n        true, // No need to check if the hub is a valid allowance target\n        _amount.amount\n      );\n\n      // Distribute to different tokens\n      uint256 _amountSpent;\n      for (uint256 j = 0; j < _distribution.length; ) {\n        uint256 _amountToDeposit = j < _distribution.length - 1\n          ? (_amount.amount * _distribution[j].shares) / MAX_TOKEN_TOTAL_SHARE\n          : _amount.amount - _amountSpent; // If this is the last token, then assign everything that hasn't been spent. We do this to prevent unspent tokens due to rounding errors\n\n        bool _failed = _depositToHub(_hub, _amount.token, _distribution[j].token, _amountToDeposit, _amount.amountOfSwaps);\n        if (!_failed) {\n          _amountSpent += _amountToDeposit;\n        }\n        unchecked {\n          j++;\n        }\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /// @inheritdoc IDCAFeeManager\n  function terminatePositions(\n    IDCAHub _hub,\n    uint256[] calldata _positionIds,\n    address _recipient\n  ) external onlyRole(ADMIN_ROLE) {\n    for (uint256 i = 0; i < _positionIds.length; ) {\n      uint256 _positionId = _positionIds[i];\n      IDCAHubPositionHandler.UserPosition memory _position = _hub.userPosition(_positionId);\n      _hub.terminate(_positionId, _recipient, _recipient);\n      delete positions[getPositionKey(address(_position.from), address(_position.to))];\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /// @inheritdoc IDCAFeeManager\n  function revokeAllowances(RevokeAction[] calldata _revokeActions) external onlyRole(ADMIN_ROLE) {\n    _revokeAllowances(_revokeActions);\n  }\n\n  /// @inheritdoc IDCAFeeManager\n  function availableBalances(IDCAHub _hub, address[] calldata _tokens) external view returns (AvailableBalance[] memory _balances) {\n    _balances = new AvailableBalance[](_tokens.length);\n    for (uint256 i = 0; i < _tokens.length; i++) {\n      address _token = _tokens[i];\n      uint256[] memory _positionIds = _positionsWithToken[_token];\n      PositionBalance[] memory _positions = new PositionBalance[](_positionIds.length);\n      for (uint256 j = 0; j < _positionIds.length; j++) {\n        IDCAHubPositionHandler.UserPosition memory _userPosition = _hub.userPosition(_positionIds[j]);\n        _positions[j] = PositionBalance({\n          positionId: _positionIds[j],\n          from: _userPosition.from,\n          to: _userPosition.to,\n          swapped: _userPosition.swapped,\n          remaining: _userPosition.remaining\n        });\n      }\n      _balances[i] = AvailableBalance({\n        token: _token,\n        platformBalance: _hub.platformBalance(_token),\n        feeManagerBalance: IERC20(_token).balanceOf(address(this)),\n        positions: _positions\n      });\n    }\n  }\n\n  function getPositionKey(address _from, address _to) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_from, _to));\n  }\n\n  function _depositToHub(\n    IDCAHub _hub,\n    address _from,\n    address _to,\n    uint256 _amount,\n    uint32 _amountOfSwaps\n  ) internal returns (bool _failed) {\n    // We will try to create or increase an existing position, but both could fail. Maybe one of the tokens is no longer\n    // allowed, or a pair not supported, so we need to check if it fails or not and act accordingly\n\n    // Find the position for this token\n    bytes32 _key = getPositionKey(_from, _to);\n    uint256 _positionId = positions[_key];\n\n    if (_positionId == 0) {\n      // If position doesn't exist, then try to create it\n      try _hub.deposit(_from, _to, _amount, _amountOfSwaps, SWAP_INTERVAL, address(this), new IDCAPermissionManager.PermissionSet[](0)) returns (\n        uint256 _newPositionId\n      ) {\n        positions[_key] = _newPositionId;\n        _positionsWithToken[_to].push(_newPositionId);\n      } catch {\n        _failed = true;\n      }\n    } else {\n      // If position exists, then try to increase it\n      try _hub.increasePosition(_positionId, _amount, _amountOfSwaps) {} catch {\n        _failed = true;\n      }\n    }\n  }\n\n  /// @dev This version does not check the swapper registry at all\n  function _maxApproveSpenderIfNeeded(\n    IERC20 _token,\n    address _spender,\n    uint256 _minAllowance\n  ) internal {\n    if (_spender != address(0)) {\n      uint256 _allowance = _token.allowance(address(this), _spender);\n      if (_allowance < _minAllowance) {\n        if (_allowance > 0) {\n          _token.approve(_spender, 0); // We do this because some tokens (like USDT) fail if we don't\n        }\n        _token.approve(_spender, type(uint256).max);\n      }\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
    },
    "contracts/interfaces/IDCAFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\nimport '@mean-finance/swappers/solidity/contracts/extensions/TakeManyRunSwapsAndTransferMany.sol';\n\n/**\n * @title DCA Fee Manager\n * @notice This contract will manage all platform fees. Since fees come in different tokens, this manager\n *         will be in charge of taking them and converting them to different tokens, for example ETH/MATIC\n *         or stablecoins. Allowed users will to withdraw fees as generated, or DCA them into tokens\n *         of their choosing\n */\ninterface IDCAFeeManager {\n  /// @notice The parameters to execute the call\n  struct RunSwapsAndTransferManyParams {\n    // The accounts that should be approved for spending\n    Allowance[] allowanceTargets;\n    // The different swappers involved in the swap\n    address[] swappers;\n    // The different swapps to execute\n    bytes[] swaps;\n    // Context necessary for the swap execution\n    SwapContext[] swapContext;\n    // Tokens to transfer after swaps have been executed\n    TransferOutBalance[] transferOutBalance;\n  }\n\n  /// @notice Represents a share of a target token\n  struct TargetTokenShare {\n    address token;\n    uint16 shares;\n  }\n\n  /// @notice Represents how much to deposit to a position, for a specific token\n  struct AmountToFill {\n    address token;\n    uint32 amountOfSwaps;\n    uint256 amount;\n  }\n\n  /// @notice Represents how much is available for withdraw, for a specific token\n  struct AvailableBalance {\n    address token;\n    uint256 platformBalance;\n    uint256 feeManagerBalance;\n    PositionBalance[] positions;\n  }\n\n  /// @notice Represents information about a specific position\n  struct PositionBalance {\n    uint256 positionId;\n    IERC20Metadata from;\n    IERC20Metadata to;\n    uint256 swapped;\n    uint256 remaining;\n  }\n\n  /**\n   * @notice The contract's owner and other allowed users can specify the target tokens that the fees\n   *         should be converted to. They can also specify the percentage assigned to each token\n   * @dev This value is constant and cannot be modified\n   * @return The numeric value that represents a 100% asignment for the fee conversion distribution\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function MAX_TOKEN_TOTAL_SHARE() external view returns (uint16);\n\n  /**\n   * @notice Returns the swap interval used for DCA swaps\n   * @dev This value is constant and cannot be modified\n   * @return The swap interval used for DCA swaps\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function SWAP_INTERVAL() external view returns (uint32);\n\n  /**\n   * @notice Returns the position id for a given (from, to) pair\n   * @dev Key for (tokenA, tokenB) is different from the key for(tokenB, tokenA)\n   * @param pairKey The key of the pair (from, to)\n   * @return The position id for the given pair\n   */\n  function positions(bytes32 pairKey) external view returns (uint256); // key(from, to) => position id\n\n  /**\n   * @notice Executes multiple swaps\n   * @dev Can only be executed by admins\n   * @param parameters The parameters for the swap\n   */\n  function runSwapsAndTransferMany(RunSwapsAndTransferManyParams calldata parameters) external payable;\n\n  /**\n   * @notice Withdraws tokens from the platform balance, and sends them to the given recipient\n   * @dev Can only be executed by admins\n   * @param hub The address of the DCA Hub\n   * @param amountToWithdraw The tokens to withdraw, and their amounts\n   * @param recipient The address of the recipient\n   */\n  function withdrawFromPlatformBalance(\n    IDCAHub hub,\n    IDCAHub.AmountOfToken[] calldata amountToWithdraw,\n    address recipient\n  ) external;\n\n  /**\n   * @notice Withdraws tokens from the contract's balance, and sends them to the given recipient\n   * @dev Can only be executed by admins\n   * @param amountToWithdraw The tokens to withdraw, and their amounts\n   * @param recipient The address of the recipient\n   */\n  function withdrawFromBalance(IDCAHub.AmountOfToken[] calldata amountToWithdraw, address recipient) external;\n\n  /**\n   * @notice Withdraws tokens from the given positions, and sends them to the given recipient\n   * @dev Can only be executed by admins\n   * @param hub The address of the DCA Hub\n   * @param positionSets The positions to withdraw from\n   * @param recipient The address of the recipient\n   */\n  function withdrawFromPositions(\n    IDCAHub hub,\n    IDCAHub.PositionSet[] calldata positionSets,\n    address recipient\n  ) external;\n\n  /**\n   * @notice Takes a certain amount of the given tokens, and sets up DCA swaps for each of them.\n   *         The given amounts can be distributed across different target tokens\n   * @dev Can only be executed by admins\n   * @param hub The address of the DCA Hub\n   * @param amounts Specific tokens and amounts to take from this contract and send to the hub\n   * @param distribution How to distribute the source tokens across different target tokens\n   */\n  function fillPositions(\n    IDCAHub hub,\n    AmountToFill[] calldata amounts,\n    TargetTokenShare[] calldata distribution\n  ) external;\n\n  /**\n   * @notice Takes list of position ids and terminates them. All swapped and unswapped balance is\n   *         sent to the given recipient. This is meant to be used only if for some reason swaps are\n   *         no longer executed\n   * @dev Can only be executed by admins\n   * @param hub The address of the DCA Hub\n   * @param positionIds The positions to terminate\n   * @param recipient The address that will receive all swapped and unswapped tokens\n   */\n  function terminatePositions(\n    IDCAHub hub,\n    uint256[] calldata positionIds,\n    address recipient\n  ) external;\n\n  /**\n   * @notice Revokes ERC20 allowances for the given spenders\n   * @dev Can only be executed by admins\n   * @param revokeActions The spenders and tokens to revoke\n   */\n  function revokeAllowances(ISwapAdapter.RevokeAction[] calldata revokeActions) external;\n\n  /**\n   * @notice Returns how much is available for withdraw, for the given tokens\n   * @dev This is meant for off-chan purposes\n   * @param hub The address of the DCA Hub\n   * @param tokens The tokens to check the balance for\n   * @return How much is available for withdraw, for the given tokens\n   */\n  function availableBalances(IDCAHub hub, address[] calldata tokens) external view returns (AvailableBalance[] memory);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport '@mean-finance/oracles/solidity/interfaces/ITokenPriceOracle.sol';\nimport './IDCAPermissionManager.sol';\n\n/**\n * @title The interface for all state related queries\n * @notice These methods allow users to read the hubs's current values\n */\ninterface IDCAHubParameters {\n  /**\n   * @notice Returns how much will the amount to swap differ from the previous swap. f.e. if the returned value is -100, then the amount to swap will be 100 less than the swap just before it\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\n   * @param tokenA One of the pair's token\n   * @param tokenB The other of the pair's token\n   * @param swapIntervalMask The byte representation of the swap interval to check\n   * @param swapNumber The swap number to check\n   * @return swapDeltaAToB How much less of token A will the following swap require\n   * @return swapDeltaBToA How much less of token B will the following swap require\n   */\n  function swapAmountDelta(\n    address tokenA,\n    address tokenB,\n    bytes1 swapIntervalMask,\n    uint32 swapNumber\n  ) external view returns (uint128 swapDeltaAToB, uint128 swapDeltaBToA);\n\n  /**\n   * @notice Returns the sum of the ratios reported in all swaps executed until the given swap number\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\n   * @param tokenA One of the pair's token\n   * @param tokenB The other of the pair's token\n   * @param swapIntervalMask The byte representation of the swap interval to check\n   * @param swapNumber The swap number to check\n   * @return accumRatioAToB The sum of all ratios from A to B\n   * @return accumRatioBToA The sum of all ratios from B to A\n   */\n  function accumRatio(\n    address tokenA,\n    address tokenB,\n    bytes1 swapIntervalMask,\n    uint32 swapNumber\n  ) external view returns (uint256 accumRatioAToB, uint256 accumRatioBToA);\n\n  /**\n   * @notice Returns swapping information about a specific pair\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\n   * @param tokenA One of the pair's token\n   * @param tokenB The other of the pair's token\n   * @param swapIntervalMask The byte representation of the swap interval to check\n   * @return performedSwaps How many swaps have been executed\n   * @return nextAmountToSwapAToB How much of token A will be swapped on the next swap\n   * @return lastSwappedAt Timestamp of the last swap\n   * @return nextAmountToSwapBToA How much of token B will be swapped on the next swap\n   */\n  function swapData(\n    address tokenA,\n    address tokenB,\n    bytes1 swapIntervalMask\n  )\n    external\n    view\n    returns (\n      uint32 performedSwaps,\n      uint224 nextAmountToSwapAToB,\n      uint32 lastSwappedAt,\n      uint224 nextAmountToSwapBToA\n    );\n\n  /**\n   * @notice Returns the byte representation of the set of actice swap intervals for the given pair\n   * @dev `tokenA` must be smaller than `tokenB` (tokenA < tokenB)\n   * @param tokenA The smaller of the pair's token\n   * @param tokenB The other of the pair's token\n   * @return The byte representation of the set of actice swap intervals\n   */\n  function activeSwapIntervals(address tokenA, address tokenB) external view returns (bytes1);\n\n  /**\n   * @notice Returns how much of the hub's token balance belongs to the platform\n   * @param token The token to check\n   * @return The amount that belongs to the platform\n   */\n  function platformBalance(address token) external view returns (uint256);\n}\n\n/**\n * @title The interface for all position related matters\n * @notice These methods allow users to create, modify and terminate their positions\n */\ninterface IDCAHubPositionHandler {\n  /// @notice The position of a certain user\n  struct UserPosition {\n    // The token that the user deposited and will be swapped in exchange for \"to\"\n    IERC20Metadata from;\n    // The token that the user will get in exchange for their \"from\" tokens in each swap\n    IERC20Metadata to;\n    // How frequently the position's swaps should be executed\n    uint32 swapInterval;\n    // How many swaps were executed since deposit, last modification, or last withdraw\n    uint32 swapsExecuted;\n    // How many \"to\" tokens can currently be withdrawn\n    uint256 swapped;\n    // How many swaps left the position has to execute\n    uint32 swapsLeft;\n    // How many \"from\" tokens there are left to swap\n    uint256 remaining;\n    // How many \"from\" tokens need to be traded in each swap\n    uint120 rate;\n  }\n\n  /// @notice A list of positions that all have the same `to` token\n  struct PositionSet {\n    // The `to` token\n    address token;\n    // The position ids\n    uint256[] positionIds;\n  }\n\n  /**\n   * @notice Emitted when a position is terminated\n   * @param user The address of the user that terminated the position\n   * @param recipientUnswapped The address of the user that will receive the unswapped tokens\n   * @param recipientSwapped The address of the user that will receive the swapped tokens\n   * @param positionId The id of the position that was terminated\n   * @param returnedUnswapped How many \"from\" tokens were returned to the caller\n   * @param returnedSwapped How many \"to\" tokens were returned to the caller\n   */\n  event Terminated(\n    address indexed user,\n    address indexed recipientUnswapped,\n    address indexed recipientSwapped,\n    uint256 positionId,\n    uint256 returnedUnswapped,\n    uint256 returnedSwapped\n  );\n\n  /**\n   * @notice Emitted when a position is created\n   * @param depositor The address of the user that creates the position\n   * @param owner The address of the user that will own the position\n   * @param positionId The id of the position that was created\n   * @param fromToken The address of the \"from\" token\n   * @param toToken The address of the \"to\" token\n   * @param swapInterval How frequently the position's swaps should be executed\n   * @param rate How many \"from\" tokens need to be traded in each swap\n   * @param startingSwap The number of the swap when the position will be executed for the first time\n   * @param lastSwap The number of the swap when the position will be executed for the last time\n   * @param permissions The permissions defined for the position\n   */\n  event Deposited(\n    address indexed depositor,\n    address indexed owner,\n    uint256 positionId,\n    address fromToken,\n    address toToken,\n    uint32 swapInterval,\n    uint120 rate,\n    uint32 startingSwap,\n    uint32 lastSwap,\n    IDCAPermissionManager.PermissionSet[] permissions\n  );\n\n  /**\n   * @notice Emitted when a position is created and extra data is provided\n   * @param positionId The id of the position that was created\n   * @param data The extra data that was provided\n   */\n  event Miscellaneous(uint256 positionId, bytes data);\n\n  /**\n   * @notice Emitted when a user withdraws all swapped tokens from a position\n   * @param withdrawer The address of the user that executed the withdraw\n   * @param recipient The address of the user that will receive the withdrawn tokens\n   * @param positionId The id of the position that was affected\n   * @param token The address of the withdrawn tokens. It's the same as the position's \"to\" token\n   * @param amount The amount that was withdrawn\n   */\n  event Withdrew(address indexed withdrawer, address indexed recipient, uint256 positionId, address token, uint256 amount);\n\n  /**\n   * @notice Emitted when a user withdraws all swapped tokens from many positions\n   * @param withdrawer The address of the user that executed the withdraws\n   * @param recipient The address of the user that will receive the withdrawn tokens\n   * @param positions The positions to withdraw from\n   * @param withdrew The total amount that was withdrawn from each token\n   */\n  event WithdrewMany(address indexed withdrawer, address indexed recipient, PositionSet[] positions, uint256[] withdrew);\n\n  /**\n   * @notice Emitted when a position is modified\n   * @param user The address of the user that modified the position\n   * @param positionId The id of the position that was modified\n   * @param rate How many \"from\" tokens need to be traded in each swap\n   * @param startingSwap The number of the swap when the position will be executed for the first time\n   * @param lastSwap The number of the swap when the position will be executed for the last time\n   */\n  event Modified(address indexed user, uint256 positionId, uint120 rate, uint32 startingSwap, uint32 lastSwap);\n\n  /// @notice Thrown when a user tries to create a position with the same `from` & `to`\n  error InvalidToken();\n\n  /// @notice Thrown when a user tries to create a position with a swap interval that is not allowed\n  error IntervalNotAllowed();\n\n  /// @notice Thrown when a user tries operate on a position that doesn't exist (it might have been already terminated)\n  error InvalidPosition();\n\n  /// @notice Thrown when a user tries operate on a position that they don't have access to\n  error UnauthorizedCaller();\n\n  /// @notice Thrown when a user tries to create a position with zero swaps\n  error ZeroSwaps();\n\n  /// @notice Thrown when a user tries to create a position with zero funds\n  error ZeroAmount();\n\n  /// @notice Thrown when a user tries to withdraw a position whose `to` token doesn't match the specified one\n  error PositionDoesNotMatchToken();\n\n  /// @notice Thrown when a user tries create or modify a position with an amount too big\n  error AmountTooBig();\n\n  /**\n   * @notice Returns the permission manager contract\n   * @return The contract itself\n   */\n  function permissionManager() external view returns (IDCAPermissionManager);\n\n  /**\n   * @notice Returns total created positions\n   * @return The total created positions\n   */\n  function totalCreatedPositions() external view returns (uint256);\n\n  /**\n   * @notice Returns a user position\n   * @param positionId The id of the position\n   * @return position The position itself\n   */\n  function userPosition(uint256 positionId) external view returns (UserPosition memory position);\n\n  /**\n   * @notice Creates a new position\n   * @dev Will revert:\n   *      - With ZeroAddress if from, to or owner are zero\n   *      - With InvalidToken if from == to\n   *      - With ZeroAmount if amount is zero\n   *      - With AmountTooBig if amount is too big\n   *      - With ZeroSwaps if amountOfSwaps is zero\n   *      - With IntervalNotAllowed if swapInterval is not allowed\n   * @param from The address of the \"from\" token\n   * @param to The address of the \"to\" token\n   * @param amount How many \"from\" tokens will be swapped in total\n   * @param amountOfSwaps How many swaps to execute for this position\n   * @param swapInterval How frequently the position's swaps should be executed\n   * @param owner The address of the owner of the position being created\n   * @param permissions Extra permissions to add to the position. Can be empty\n   * @return positionId The id of the created position\n   */\n  function deposit(\n    address from,\n    address to,\n    uint256 amount,\n    uint32 amountOfSwaps,\n    uint32 swapInterval,\n    address owner,\n    IDCAPermissionManager.PermissionSet[] calldata permissions\n  ) external returns (uint256 positionId);\n\n  /**\n   * @notice Creates a new position\n   * @dev Will revert:\n   *      - With ZeroAddress if from, to or owner are zero\n   *      - With InvalidToken if from == to\n   *      - With ZeroAmount if amount is zero\n   *      - With AmountTooBig if amount is too big\n   *      - With ZeroSwaps if amountOfSwaps is zero\n   *      - With IntervalNotAllowed if swapInterval is not allowed\n   * @param from The address of the \"from\" token\n   * @param to The address of the \"to\" token\n   * @param amount How many \"from\" tokens will be swapped in total\n   * @param amountOfSwaps How many swaps to execute for this position\n   * @param swapInterval How frequently the position's swaps should be executed\n   * @param owner The address of the owner of the position being created\n   * @param permissions Extra permissions to add to the position. Can be empty\n   * @param miscellaneous Bytes that will be emitted, and associated with the position\n   * @return positionId The id of the created position\n   */\n  function deposit(\n    address from,\n    address to,\n    uint256 amount,\n    uint32 amountOfSwaps,\n    uint32 swapInterval,\n    address owner,\n    IDCAPermissionManager.PermissionSet[] calldata permissions,\n    bytes calldata miscellaneous\n  ) external returns (uint256 positionId);\n\n  /**\n   * @notice Withdraws all swapped tokens from a position to a recipient\n   * @dev Will revert:\n   *      - With InvalidPosition if positionId is invalid\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\n   *      - With ZeroAddress if recipient is zero\n   * @param positionId The position's id\n   * @param recipient The address to withdraw swapped tokens to\n   * @return swapped How much was withdrawn\n   */\n  function withdrawSwapped(uint256 positionId, address recipient) external returns (uint256 swapped);\n\n  /**\n   * @notice Withdraws all swapped tokens from multiple positions\n   * @dev Will revert:\n   *      - With InvalidPosition if any of the position ids are invalid\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position to any of the given positions\n   *      - With ZeroAddress if recipient is zero\n   *      - With PositionDoesNotMatchToken if any of the positions do not match the token in their position set\n   * @param positions A list positions, grouped by `to` token\n   * @param recipient The address to withdraw swapped tokens to\n   * @return withdrawn How much was withdrawn for each token\n   */\n  function withdrawSwappedMany(PositionSet[] calldata positions, address recipient) external returns (uint256[] memory withdrawn);\n\n  /**\n   * @notice Takes the unswapped balance, adds the new deposited funds and modifies the position so that\n   * it is executed in newSwaps swaps\n   * @dev Will revert:\n   *      - With InvalidPosition if positionId is invalid\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\n   *      - With AmountTooBig if amount is too big\n   * @param positionId The position's id\n   * @param amount Amount of funds to add to the position\n   * @param newSwaps The new amount of swaps\n   */\n  function increasePosition(\n    uint256 positionId,\n    uint256 amount,\n    uint32 newSwaps\n  ) external;\n\n  /**\n   * @notice Withdraws the specified amount from the unswapped balance and modifies the position so that\n   * it is executed in newSwaps swaps\n   * @dev Will revert:\n   *      - With InvalidPosition if positionId is invalid\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\n   *      - With ZeroSwaps if newSwaps is zero and amount is not the total unswapped balance\n   * @param positionId The position's id\n   * @param amount Amount of funds to withdraw from the position\n   * @param newSwaps The new amount of swaps\n   * @param recipient The address to send tokens to\n   */\n  function reducePosition(\n    uint256 positionId,\n    uint256 amount,\n    uint32 newSwaps,\n    address recipient\n  ) external;\n\n  /**\n   * @notice Terminates the position and sends all unswapped and swapped balance to the specified recipients\n   * @dev Will revert:\n   *      - With InvalidPosition if positionId is invalid\n   *      - With UnauthorizedCaller if the caller doesn't have access to the position\n   *      - With ZeroAddress if recipientUnswapped or recipientSwapped is zero\n   * @param positionId The position's id\n   * @param recipientUnswapped The address to withdraw unswapped tokens to\n   * @param recipientSwapped The address to withdraw swapped tokens to\n   * @return unswapped The unswapped balance sent to `recipientUnswapped`\n   * @return swapped The swapped balance sent to `recipientSwapped`\n   */\n  function terminate(\n    uint256 positionId,\n    address recipientUnswapped,\n    address recipientSwapped\n  ) external returns (uint256 unswapped, uint256 swapped);\n}\n\n/**\n * @title The interface for all swap related matters\n * @notice These methods allow users to get information about the next swap, and how to execute it\n */\ninterface IDCAHubSwapHandler {\n  /// @notice Information about a swap\n  struct SwapInfo {\n    // The tokens involved in the swap\n    TokenInSwap[] tokens;\n    // The pairs involved in the swap\n    PairInSwap[] pairs;\n  }\n\n  /// @notice Information about a token's role in a swap\n  struct TokenInSwap {\n    // The token's address\n    address token;\n    // How much will be given of this token as a reward\n    uint256 reward;\n    // How much of this token needs to be provided by swapper\n    uint256 toProvide;\n    // How much of this token will be paid to the platform\n    uint256 platformFee;\n  }\n\n  /// @notice Information about a pair in a swap\n  struct PairInSwap {\n    // The address of one of the tokens\n    address tokenA;\n    // The address of the other token\n    address tokenB;\n    // The total amount of token A swapped in this pair\n    uint256 totalAmountToSwapTokenA;\n    // The total amount of token B swapped in this pair\n    uint256 totalAmountToSwapTokenB;\n    // How much is 1 unit of token A when converted to B\n    uint256 ratioAToB;\n    // How much is 1 unit of token B when converted to A\n    uint256 ratioBToA;\n    // The swap intervals involved in the swap, represented as a byte\n    bytes1 intervalsInSwap;\n  }\n\n  /// @notice A pair of tokens, represented by their indexes in an array\n  struct PairIndexes {\n    // The index of the token A\n    uint8 indexTokenA;\n    // The index of the token B\n    uint8 indexTokenB;\n  }\n\n  /**\n   * @notice Emitted when a swap is executed\n   * @param sender The address of the user that initiated the swap\n   * @param rewardRecipient The address that received the reward\n   * @param callbackHandler The address that executed the callback\n   * @param swapInformation All information related to the swap\n   * @param borrowed How much was borrowed\n   * @param fee The swap fee at the moment of the swap\n   */\n  event Swapped(\n    address indexed sender,\n    address indexed rewardRecipient,\n    address indexed callbackHandler,\n    SwapInfo swapInformation,\n    uint256[] borrowed,\n    uint32 fee\n  );\n\n  /// @notice Thrown when pairs indexes are not sorted correctly\n  error InvalidPairs();\n\n  /// @notice Thrown when trying to execute a swap, but there is nothing to swap\n  error NoSwapsToExecute();\n\n  /**\n   * @notice Returns all information related to the next swap\n   * @dev Will revert with:\n   *      - With InvalidTokens if tokens are not sorted, or if there are duplicates\n   *      - With InvalidPairs if pairs are not sorted (first by indexTokenA and then indexTokenB), or if indexTokenA >= indexTokenB for any pair\n   * @param tokens The tokens involved in the next swap\n   * @param pairs The pairs that you want to swap. Each element of the list points to the index of the token in the tokens array\n   * @param calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\n   *        the possibility to calculate the next swap information for privileged and non-privileged accounts\n   * @param oracleData Bytes to send to the oracle when executing a quote\n   * @return swapInformation The information about the next swap\n   */\n  function getNextSwapInfo(\n    address[] calldata tokens,\n    PairIndexes[] calldata pairs,\n    bool calculatePrivilegedAvailability,\n    bytes calldata oracleData\n  ) external view returns (SwapInfo memory swapInformation);\n\n  /**\n   * @notice Executes a flash swap\n   * @dev Will revert with:\n   *      - With InvalidTokens if tokens are not sorted, or if there are duplicates\n   *      - With InvalidPairs if pairs are not sorted (first by indexTokenA and then indexTokenB), or if indexTokenA >= indexTokenB for any pair\n   *      - With Paused if swaps are paused by protocol\n   *      - With NoSwapsToExecute if there are no swaps to execute for the given pairs\n   *      - With LiquidityNotReturned if the required tokens were not back during the callback\n   * @param tokens The tokens involved in the next swap\n   * @param pairsToSwap The pairs that you want to swap. Each element of the list points to the index of the token in the tokens array\n   * @param rewardRecipient The address to send the reward to\n   * @param callbackHandler Address to call for callback (and send the borrowed tokens to)\n   * @param borrow How much to borrow of each of the tokens in tokens. The amount must match the position of the token in the tokens array\n   * @param callbackData Bytes to send to the caller during the callback\n   * @param oracleData Bytes to send to the oracle when executing a quote\n   * @return Information about the executed swap\n   */\n  function swap(\n    address[] calldata tokens,\n    PairIndexes[] calldata pairsToSwap,\n    address rewardRecipient,\n    address callbackHandler,\n    uint256[] calldata borrow,\n    bytes calldata callbackData,\n    bytes calldata oracleData\n  ) external returns (SwapInfo memory);\n}\n\n/**\n * @title The interface for handling all configuration\n * @notice This contract will manage configuration that affects all pairs, swappers, etc\n */\ninterface IDCAHubConfigHandler {\n  /**\n   * @notice Emitted when a new oracle is set\n   * @param oracle The new oracle contract\n   */\n  event OracleSet(ITokenPriceOracle oracle);\n\n  /**\n   * @notice Emitted when a new swap fee is set\n   * @param feeSet The new swap fee\n   */\n  event SwapFeeSet(uint32 feeSet);\n\n  /**\n   * @notice Emitted when new swap intervals are allowed\n   * @param swapIntervals The new swap intervals\n   */\n  event SwapIntervalsAllowed(uint32[] swapIntervals);\n\n  /**\n   * @notice Emitted when some swap intervals are no longer allowed\n   * @param swapIntervals The swap intervals that are no longer allowed\n   */\n  event SwapIntervalsForbidden(uint32[] swapIntervals);\n\n  /**\n   * @notice Emitted when a new platform fee ratio is set\n   * @param platformFeeRatio The new platform fee ratio\n   */\n  event PlatformFeeRatioSet(uint16 platformFeeRatio);\n\n  /**\n   * @notice Emitted when allowed states of tokens are updated\n   * @param tokens Array of updated tokens\n   * @param allowed Array of new allow state per token were allowed[i] is the updated state of tokens[i]\n   */\n  event TokensAllowedUpdated(address[] tokens, bool[] allowed);\n\n  /// @notice Thrown when trying to interact with an unallowed token\n  error UnallowedToken();\n\n  /// @notice Thrown when set allowed tokens input is not valid\n  error InvalidAllowedTokensInput();\n\n  /// @notice Thrown when trying to set a fee higher than the maximum allowed\n  error HighFee();\n\n  /// @notice Thrown when trying to set a fee that is not multiple of 100\n  error InvalidFee();\n\n  /// @notice Thrown when trying to set a fee ratio that is higher that the maximum allowed\n  error HighPlatformFeeRatio();\n\n  /**\n   * @notice Returns the max fee ratio that can be set\n   * @dev Cannot be modified\n   * @return The maximum possible value\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function MAX_PLATFORM_FEE_RATIO() external view returns (uint16);\n\n  /**\n   * @notice Returns the fee charged on swaps\n   * @return swapFee The fee itself\n   */\n  function swapFee() external view returns (uint32 swapFee);\n\n  /**\n   * @notice Returns the price oracle contract\n   * @return oracle The contract itself\n   */\n  function oracle() external view returns (ITokenPriceOracle oracle);\n\n  /**\n   * @notice Returns how much will the platform take from the fees collected in swaps\n   * @return The current ratio\n   */\n  function platformFeeRatio() external view returns (uint16);\n\n  /**\n   * @notice Returns the max fee that can be set for swaps\n   * @dev Cannot be modified\n   * @return maxFee The maximum possible fee\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function MAX_FEE() external view returns (uint32 maxFee);\n\n  /**\n   * @notice Returns a byte that represents allowed swap intervals\n   * @return allowedSwapIntervals The allowed swap intervals\n   */\n  function allowedSwapIntervals() external view returns (bytes1 allowedSwapIntervals);\n\n  /**\n   * @notice Returns if a token is currently allowed or not\n   * @return Allowed state of token\n   */\n  function allowedTokens(address token) external view returns (bool);\n\n  /**\n   * @notice Returns token's magnitude (10**decimals)\n   * @return Stored magnitude for token\n   */\n  function tokenMagnitude(address token) external view returns (uint120);\n\n  /**\n   * @notice Returns whether swaps and deposits are currently paused\n   * @return isPaused Whether swaps and deposits are currently paused\n   */\n  function paused() external view returns (bool isPaused);\n\n  /**\n   * @notice Sets a new swap fee\n   * @dev Will revert with HighFee if the fee is higher than the maximum\n   * @dev Will revert with InvalidFee if the fee is not multiple of 100\n   * @param fee The new swap fee\n   */\n  function setSwapFee(uint32 fee) external;\n\n  /**\n   * @notice Sets a new price oracle\n   * @dev Will revert with ZeroAddress if the zero address is passed\n   * @param oracle The new oracle contract\n   */\n  function setOracle(ITokenPriceOracle oracle) external;\n\n  /**\n   * @notice Sets a new platform fee ratio\n   * @dev Will revert with HighPlatformFeeRatio if given ratio is too high\n   * @param platformFeeRatio The new ratio\n   */\n  function setPlatformFeeRatio(uint16 platformFeeRatio) external;\n\n  /**\n   * @notice Adds new swap intervals to the allowed list\n   * @param swapIntervals The new swap intervals\n   */\n  function addSwapIntervalsToAllowedList(uint32[] calldata swapIntervals) external;\n\n  /**\n   * @notice Removes some swap intervals from the allowed list\n   * @param swapIntervals The swap intervals to remove\n   */\n  function removeSwapIntervalsFromAllowedList(uint32[] calldata swapIntervals) external;\n\n  /// @notice Pauses all swaps and deposits\n  function pause() external;\n\n  /// @notice Unpauses all swaps and deposits\n  function unpause() external;\n}\n\n/**\n * @title The interface for handling platform related actions\n * @notice This contract will handle all actions that affect the platform in some way\n */\ninterface IDCAHubPlatformHandler {\n  /**\n   * @notice Emitted when someone withdraws from the paltform balance\n   * @param sender The address of the user that initiated the withdraw\n   * @param recipient The address that received the withdraw\n   * @param amounts The tokens (and the amount) that were withdrawn\n   */\n  event WithdrewFromPlatform(address indexed sender, address indexed recipient, IDCAHub.AmountOfToken[] amounts);\n\n  /**\n   * @notice Withdraws tokens from the platform balance\n   * @param amounts The amounts to withdraw\n   * @param recipient The address that will receive the tokens\n   */\n  function withdrawFromPlatformBalance(IDCAHub.AmountOfToken[] calldata amounts, address recipient) external;\n}\n\ninterface IDCAHub is IDCAHubParameters, IDCAHubConfigHandler, IDCAHubSwapHandler, IDCAHubPositionHandler, IDCAHubPlatformHandler {\n  /// @notice Specifies an amount of a token. For example to determine how much to borrow from certain tokens\n  struct AmountOfToken {\n    // The tokens' address\n    address token;\n    // How much to borrow or withdraw of the specified token\n    uint256 amount;\n  }\n\n  /// @notice Thrown when one of the parameters is a zero address\n  error ZeroAddress();\n\n  /// @notice Thrown when the expected liquidity is not returned in flash swaps\n  error LiquidityNotReturned();\n\n  /// @notice Thrown when a list of token pairs is not sorted, or if there are duplicates\n  error InvalidTokens();\n}\n"
    },
    "@mean-finance/swappers/solidity/contracts/extensions/TakeManyRunSwapsAndTransferMany.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport './Shared.sol';\nimport '../SwapAdapter.sol';\n\nabstract contract TakeManyRunSwapsAndTransferMany is SwapAdapter {\n  /// @notice The parameters to execute the call\n  struct TakeManyRunSwapsAndTransferManyParams {\n    // The tokens (and amounts) to take from the caller\n    TakeFromCaller[] takeFromCaller;\n    // The accounts that should be approved for spending\n    Allowance[] allowanceTargets;\n    // The different swappers involved in the swap\n    address[] swappers;\n    // The different swapps to execute\n    bytes[] swaps;\n    // Context necessary for the swap execution\n    SwapContext[] swapContext;\n    // Tokens to transfer after swaps have been executed\n    TransferOutBalance[] transferOutBalance;\n  }\n\n  /**\n   * @notice Takes many tokens from the caller, and executes many different swaps. These swaps can be chained between\n   *         each other, or totally independent. After the swaps are executed, the caller can specify that tokens\n   *         that remained in the contract should be sent to different recipients. These tokens could be either\n   *         the result of the swaps, or unspent tokens\n   * @dev This function can only be executed with swappers that are allowlisted\n   * @param _parameters The parameters for the swap\n   */\n  function takeManyRunSwapsAndTransferMany(TakeManyRunSwapsAndTransferManyParams calldata _parameters) public payable virtual {\n    // Take from caller\n    for (uint256 i = 0; i < _parameters.takeFromCaller.length; ) {\n      TakeFromCaller memory _takeFromCaller = _parameters.takeFromCaller[i];\n      _takeFromMsgSender(_takeFromCaller.token, _takeFromCaller.amount);\n      unchecked {\n        i++;\n      }\n    }\n\n    // Validate that all swappers are allowlisted\n    for (uint256 i = 0; i < _parameters.swappers.length; ) {\n      _assertSwapperIsAllowlisted(_parameters.swappers[i]);\n      unchecked {\n        i++;\n      }\n    }\n\n    // Approve whatever is necessary\n    for (uint256 i = 0; i < _parameters.allowanceTargets.length; ) {\n      Allowance memory _allowance = _parameters.allowanceTargets[i];\n      _maxApproveSpenderIfNeeded(_allowance.token, _allowance.allowanceTarget, false, _allowance.minAllowance);\n      unchecked {\n        i++;\n      }\n    }\n\n    // Execute swaps\n    for (uint256 i = 0; i < _parameters.swaps.length; ) {\n      SwapContext memory _context = _parameters.swapContext[i];\n      _executeSwap(_parameters.swappers[_context.swapperIndex], _parameters.swaps[i], _context.value);\n      unchecked {\n        i++;\n      }\n    }\n\n    // Transfer out whatever was left in the contract\n    for (uint256 i = 0; i < _parameters.transferOutBalance.length; ) {\n      TransferOutBalance memory _transferOutBalance = _parameters.transferOutBalance[i];\n      _sendBalanceOnContractToRecipient(_transferOutBalance.token, _transferOutBalance.recipient);\n      unchecked {\n        i++;\n      }\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@mean-finance/oracles/solidity/interfaces/ITokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/**\n * @title The interface for an oracle that provides price quotes\n * @notice These methods allow users to add support for pairs, and then ask for quotes\n */\ninterface ITokenPriceOracle {\n  /// @notice Thrown when trying to add support for a pair that cannot be supported\n  error PairCannotBeSupported(address tokenA, address tokenB);\n\n  /// @notice Thrown when trying to execute a quote with a pair that isn't supported yet\n  error PairNotSupportedYet(address tokenA, address tokenB);\n\n  /**\n   * @notice Returns whether this oracle can support the given pair of tokens\n   * @dev tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\n   * @param tokenA One of the pair's tokens\n   * @param tokenB The other of the pair's tokens\n   * @return Whether the given pair of tokens can be supported by the oracle\n   */\n  function canSupportPair(address tokenA, address tokenB) external view returns (bool);\n\n  /**\n   * @notice Returns whether this oracle is already supporting the given pair of tokens\n   * @dev tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\n   * @param tokenA One of the pair's tokens\n   * @param tokenB The other of the pair's tokens\n   * @return Whether the given pair of tokens is already being supported by the oracle\n   */\n  function isPairAlreadySupported(address tokenA, address tokenB) external view returns (bool);\n\n  /**\n   * @notice Returns a quote, based on the given tokens and amount\n   * @dev Will revert if pair isn't supported\n   * @param tokenIn The token that will be provided\n   * @param amountIn The amount that will be provided\n   * @param tokenOut The token we would like to quote\n   * @param data Custom data that the oracle might need to operate\n   * @return amountOut How much `tokenOut` will be returned in exchange for `amountIn` amount of `tokenIn`\n   */\n  function quote(\n    address tokenIn,\n    uint256 amountIn,\n    address tokenOut,\n    bytes calldata data\n  ) external view returns (uint256 amountOut);\n\n  /**\n   * @notice Add or reconfigures the support for a given pair. This function will let the oracle take some actions\n   *         to configure the pair, in preparation for future quotes. Can be called many times in order to let the oracle\n   *         re-configure for a new context\n   * @dev Will revert if pair cannot be supported. tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\n   * @param tokenA One of the pair's tokens\n   * @param tokenB The other of the pair's tokens\n   * @param data Custom data that the oracle might need to operate\n   */\n  function addOrModifySupportForPair(\n    address tokenA,\n    address tokenB,\n    bytes calldata data\n  ) external;\n\n  /**\n   * @notice Adds support for a given pair if the oracle didn't support it already. If called for a pair that is already supported,\n   *         then nothing will happen. This function will let the oracle take some actions to configure the pair, in preparation\n   *         for future quotes\n   * @dev Will revert if pair cannot be supported. tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\n   * @param tokenA One of the pair's tokens\n   * @param tokenB The other of the pair's tokens\n   * @param data Custom data that the oracle might need to operate\n   */\n  function addSupportForPairIfNeeded(\n    address tokenA,\n    address tokenB,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "@mean-finance/dca-v2-core/contracts/interfaces/IDCAPermissionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@mean-finance/nft-descriptors/solidity/interfaces/IDCAHubPositionDescriptor.sol';\n\ninterface IERC721BasicEnumerable {\n  /**\n   * @notice Count NFTs tracked by this contract\n   * @return A count of valid NFTs tracked by this contract, where each one of\n   *         them has an assigned and queryable owner not equal to the zero address\n   */\n  function totalSupply() external view returns (uint256);\n}\n\n/**\n * @title The interface for all permission related matters\n * @notice These methods allow users to set and remove permissions to their positions\n */\ninterface IDCAPermissionManager is IERC721, IERC721BasicEnumerable {\n  /// @notice Set of possible permissions\n  enum Permission {\n    INCREASE,\n    REDUCE,\n    WITHDRAW,\n    TERMINATE\n  }\n\n  /// @notice A set of permissions for a specific operator\n  struct PermissionSet {\n    // The address of the operator\n    address operator;\n    // The permissions given to the overator\n    Permission[] permissions;\n  }\n\n  /// @notice A collection of permissions sets for a specific position\n  struct PositionPermissions {\n    // The id of the token\n    uint256 tokenId;\n    // The permissions to assign to the position\n    PermissionSet[] permissionSets;\n  }\n\n  /**\n   * @notice Emitted when permissions for a token are modified\n   * @param tokenId The id of the token\n   * @param permissions The set of permissions that were updated\n   */\n  event Modified(uint256 tokenId, PermissionSet[] permissions);\n\n  /**\n   * @notice Emitted when the address for a new descritor is set\n   * @param descriptor The new descriptor contract\n   */\n  event NFTDescriptorSet(IDCAHubPositionDescriptor descriptor);\n\n  /// @notice Thrown when a user tries to set the hub, once it was already set\n  error HubAlreadySet();\n\n  /// @notice Thrown when a user provides a zero address when they shouldn't\n  error ZeroAddress();\n\n  /// @notice Thrown when a user calls a method that can only be executed by the hub\n  error OnlyHubCanExecute();\n\n  /// @notice Thrown when a user tries to modify permissions for a token they do not own\n  error NotOwner();\n\n  /// @notice Thrown when a user tries to execute a permit with an expired deadline\n  error ExpiredDeadline();\n\n  /// @notice Thrown when a user tries to execute a permit with an invalid signature\n  error InvalidSignature();\n\n  /**\n   * @notice The permit typehash used in the permit signature\n   * @return The typehash for the permit\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  /**\n   * @notice The permit typehash used in the permission permit signature\n   * @return The typehash for the permission permit\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function PERMISSION_PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  /**\n   * @notice The permit typehash used in the multi permission permit signature\n   * @return The typehash for the multi permission permit\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function MULTI_PERMISSION_PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  /**\n   * @notice The permit typehash used in the permission permit signature\n   * @return The typehash for the permission set\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function PERMISSION_SET_TYPEHASH() external pure returns (bytes32);\n\n  /**\n   * @notice The permit typehash used in the multi permission permit signature\n   * @return The typehash for the position permissions\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function POSITION_PERMISSIONS_TYPEHASH() external pure returns (bytes32);\n\n  /**\n   * @notice The domain separator used in the permit signature\n   * @return The domain seperator used in encoding of permit signature\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice Returns the NFT descriptor contract\n   * @return The contract for the NFT descriptor\n   */\n  function nftDescriptor() external returns (IDCAHubPositionDescriptor);\n\n  /**\n   * @notice Returns the address of the DCA Hub\n   * @return The address of the DCA Hub\n   */\n  function hub() external returns (address);\n\n  /**\n   * @notice Returns the next nonce to use for a given user\n   * @param user The address of the user\n   * @return nonce The next nonce to use\n   */\n  function nonces(address user) external returns (uint256 nonce);\n\n  /**\n   * @notice Returns whether the given address has the permission for the given token\n   * @param id The id of the token to check\n   * @param account The address of the user to check\n   * @param permission The permission to check\n   * @return Whether the user has the permission or not\n   */\n  function hasPermission(\n    uint256 id,\n    address account,\n    Permission permission\n  ) external view returns (bool);\n\n  /**\n   * @notice Returns whether the given address has the permissions for the given token\n   * @param id The id of the token to check\n   * @param account The address of the user to check\n   * @param permissions The permissions to check\n   * @return hasPermissions Whether the user has each permission or not\n   */\n  function hasPermissions(\n    uint256 id,\n    address account,\n    Permission[] calldata permissions\n  ) external view returns (bool[] memory hasPermissions);\n\n  /**\n   * @notice Sets the address for the hub\n   * @dev Can only be successfully executed once. Once it's set, it can be modified again\n   *      Will revert:\n   *      - With ZeroAddress if address is zero\n   *      - With HubAlreadySet if the hub has already been set\n   * @param hub The address to set for the hub\n   */\n  function setHub(address hub) external;\n\n  /**\n   * @notice Mints a new NFT with the given id, and sets the permissions for it\n   * @dev Will revert with OnlyHubCanExecute if the caller is not the hub\n   * @param id The id of the new NFT\n   * @param owner The owner of the new NFT\n   * @param permissions Permissions to set for the new NFT\n   */\n  function mint(\n    uint256 id,\n    address owner,\n    PermissionSet[] calldata permissions\n  ) external;\n\n  /**\n   * @notice Burns the NFT with the given id, and clears all permissions\n   * @dev Will revert with OnlyHubCanExecute if the caller is not the hub\n   * @param id The token's id\n   */\n  function burn(uint256 id) external;\n\n  /**\n   * @notice Sets new permissions for the given position\n   * @dev Will revert with NotOwner if the caller is not the token's owner.\n   *      Operators that are not part of the given permission sets do not see their permissions modified.\n   *      In order to remove permissions to an operator, provide an empty list of permissions for them\n   * @param id The token's id\n   * @param permissions A list of permission sets\n   */\n  function modify(uint256 id, PermissionSet[] calldata permissions) external;\n\n  /**\n   * @notice Sets new permissions for the given positions\n   * @dev This is basically the same as executing multiple `modify`\n   * @param permissions A list of position permissions to set\n   */\n  function modifyMany(PositionPermissions[] calldata permissions) external;\n\n  /**\n   * @notice Approves spending of a specific token ID by spender via signature\n   * @param spender The account that is being approved\n   * @param tokenId The ID of the token that is being approved for spending\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n   */\n  function permit(\n    address spender,\n    uint256 tokenId,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice Sets permissions via signature\n   * @dev This method works similarly to `modifyMany`, but instead of being executed by the owner, it can be set by signature\n   * @param permissions The permissions to set for the different positions\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n   */\n  function multiPermissionPermit(\n    PositionPermissions[] calldata permissions,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice Sets permissions via signature\n   * @dev This method works similarly to `modify`, but instead of being executed by the owner, it can be set my signature\n   * @param permissions The permissions to set\n   * @param tokenId The token's id\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n   */\n  function permissionPermit(\n    PermissionSet[] calldata permissions,\n    uint256 tokenId,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice Sets a new NFT descriptor\n   * @dev Will revert with ZeroAddress if address is zero\n   * @param descriptor The new NFT descriptor contract\n   */\n  function setNFTDescriptor(IDCAHubPositionDescriptor descriptor) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@mean-finance/nft-descriptors/solidity/interfaces/IDCAHubPositionDescriptor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\n/**\n * @title The interface for generating a description for a position in a DCA Hub\n * @notice Contracts that implement this interface must return a base64 JSON with the entire description\n */\ninterface IDCAHubPositionDescriptor {\n  /**\n   * @notice Generates a positions's description, both the JSON and the image inside\n   * @param hub The address of the DCA Hub\n   * @param positionId The token/position id\n   * @return description The position's description\n   */\n  function tokenURI(address hub, uint256 positionId) external view returns (string memory description);\n}\n"
    },
    "@mean-finance/swappers/solidity/contracts/extensions/Shared.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/// @notice An amount to take form the caller\nstruct TakeFromCaller {\n  // The token that will be taken from the caller\n  IERC20 token;\n  // The amount that will be taken\n  uint256 amount;\n}\n\n/// @notice An allowance to provide for the swaps to work\nstruct Allowance {\n  // The token that should be approved\n  IERC20 token;\n  // The spender\n  address allowanceTarget;\n  // The minimum allowance needed\n  uint256 minAllowance;\n}\n\n/// @notice A swap to execute\nstruct Swap {\n  // The index of the swapper in the list of swappers\n  uint8 swapperIndex;\n  // The data to send to the swapper\n  bytes swapData;\n}\n\n/// @notice A token that was left on the contract and should be transferred out\nstruct TransferOutBalance {\n  // The token to transfer\n  address token;\n  // The recipient of those tokens\n  address recipient;\n}\n\n/// @notice Context necessary for the swap execution\nstruct SwapContext {\n  // The index of the swapper that should execute each swap. This might look strange but it's way cheaper than alternatives\n  uint8 swapperIndex;\n  // The ETH/MATIC/BNB to send as part of the swap\n  uint256 value;\n}\n"
    },
    "@mean-finance/swappers/solidity/contracts/SwapAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '../interfaces/ISwapAdapter.sol';\n\nabstract contract SwapAdapter is ISwapAdapter {\n  using SafeERC20 for IERC20;\n  using Address for address;\n  using Address for address payable;\n\n  /// @inheritdoc ISwapAdapter\n  address public constant PROTOCOL_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  /// @inheritdoc ISwapAdapter\n  ISwapperRegistry public immutable SWAPPER_REGISTRY;\n\n  constructor(address _swapperRegistry) {\n    if (_swapperRegistry == address(0)) revert ZeroAddress();\n    SWAPPER_REGISTRY = ISwapperRegistry(_swapperRegistry);\n  }\n\n  receive() external payable {}\n\n  /**\n   * @notice Takes the given amount of tokens from the caller\n   * @param _token The token to check\n   * @param _amount The amount to take\n   */\n  function _takeFromMsgSender(IERC20 _token, uint256 _amount) internal virtual {\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n  }\n\n  /**\n   * @notice Checks if the given spender has enough allowance, and approves the max amount\n   *         if it doesn't\n   * @param _token The token to check\n   * @param _spender The spender to check\n   * @param _minAllowance The min allowance. If the spender has over this amount, then no extra approve is needed\n   */\n  function _maxApproveSpenderIfNeeded(\n    IERC20 _token,\n    address _spender,\n    bool _alreadyValidatedSpender,\n    uint256 _minAllowance\n  ) internal virtual {\n    if (_spender != address(0)) {\n      uint256 _allowance = _token.allowance(address(this), _spender);\n      if (_allowance < _minAllowance) {\n        if (!_alreadyValidatedSpender && !SWAPPER_REGISTRY.isValidAllowanceTarget(_spender)) {\n          revert InvalidAllowanceTarget(_spender);\n        }\n        if (_allowance > 0) {\n          _token.approve(_spender, 0); // We do this because some tokens (like USDT) fail if we don't\n        }\n        _token.approve(_spender, type(uint256).max);\n      }\n    }\n  }\n\n  /**\n   * @notice Executes a swap for the given swapper\n   * @param _swapper The actual swapper\n   * @param _swapData The swap execution data\n   */\n  function _executeSwap(\n    address _swapper,\n    bytes calldata _swapData,\n    uint256 _value\n  ) internal virtual {\n    _swapper.functionCallWithValue(_swapData, _value);\n  }\n\n  /**\n   * @notice Checks if the contract has any balance of the given token, and if it does,\n   *         it sends it to the given recipient\n   * @param _token The token to check\n   * @param _recipient The recipient of the token balance\n   */\n  function _sendBalanceOnContractToRecipient(address _token, address _recipient) internal virtual {\n    uint256 _balance = _token == PROTOCOL_TOKEN ? address(this).balance : IERC20(_token).balanceOf(address(this));\n    if (_balance > 0) {\n      _sendToRecipient(_token, _balance, _recipient);\n    }\n  }\n\n  /**\n   * @notice Transfers the given amount of tokens from the contract to the recipient\n   * @param _token The token to check\n   * @param _amount The amount to send\n   * @param _recipient The recipient\n   */\n  function _sendToRecipient(\n    address _token,\n    uint256 _amount,\n    address _recipient\n  ) internal virtual {\n    if (_recipient == address(0)) _recipient = msg.sender;\n    if (_token == PROTOCOL_TOKEN) {\n      payable(_recipient).sendValue(_amount);\n    } else {\n      IERC20(_token).safeTransfer(_recipient, _amount);\n    }\n  }\n\n  /**\n   * @notice Checks if given swapper is allowlisted, and fails if it isn't\n   * @param _swapper The swapper to check\n   */\n  function _assertSwapperIsAllowlisted(address _swapper) internal view {\n    if (!SWAPPER_REGISTRY.isSwapperAllowlisted(_swapper)) revert SwapperNotAllowlisted(_swapper);\n  }\n\n  /**\n   * @notice Revokes ERC20 allowances for the given spenders\n   * @dev If exposed, then it should be permissioned\n   * @param _revokeActions The spenders and tokens to revoke\n   */\n  function _revokeAllowances(RevokeAction[] calldata _revokeActions) internal virtual {\n    for (uint256 i = 0; i < _revokeActions.length; ) {\n      RevokeAction memory _action = _revokeActions[i];\n      for (uint256 j = 0; j < _action.tokens.length; ) {\n        _action.tokens[j].approve(_action.spender, 0);\n        unchecked {\n          j++;\n        }\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  modifier onlyAllowlisted(address _swapper) {\n    _assertSwapperIsAllowlisted(_swapper);\n    _;\n  }\n}\n"
    },
    "@mean-finance/swappers/solidity/interfaces/ISwapAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport './ISwapperRegistry.sol';\n\n/**\n * @notice This abstract contract will give contracts that implement it swapping capabilities. It will\n *         take a swapper and a swap's data, and if the swapper is valid, it will execute the swap\n */\ninterface ISwapAdapter {\n  /// @notice Describes how the allowance should be revoked for the given spender\n  struct RevokeAction {\n    address spender;\n    IERC20[] tokens;\n  }\n\n  /// @notice Thrown when one of the parameters is a zero address\n  error ZeroAddress();\n\n  /**\n   * @notice Thrown when trying to execute a swap with a swapper that is not allowlisted\n   * @param swapper The swapper that was not allowlisted\n   */\n  error SwapperNotAllowlisted(address swapper);\n\n  /// @notice Thrown when the allowance target is not allowed by the swapper registry\n  error InvalidAllowanceTarget(address spender);\n\n  /**\n   * @notice Returns the address of the swapper registry\n   * @dev Cannot be modified\n   * @return The address of the swapper registry\n   */\n  function SWAPPER_REGISTRY() external view returns (ISwapperRegistry);\n\n  /**\n   * @notice Returns the address of the protocol token\n   * @dev Cannot be modified\n   * @return The address of the protocol token;\n   */\n  function PROTOCOL_TOKEN() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@mean-finance/swappers/solidity/interfaces/ISwapperRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\n/**\n * @notice This contract will act as a registry to allowlist swappers. Different contracts from the Mean\n *         ecosystem will ask this contract if an address is a valid swapper or not\n *         In some cases, swappers have supplementary allowance targets that need ERC20 approvals. We\n *         will also track those here\n */\ninterface ISwapperRegistry {\n  /// @notice Thrown when one of the parameters is a zero address\n  error ZeroAddress();\n\n  /// @notice Thrown when trying to remove an account from the swappers list, when it wasn't there before\n  error AccountIsNotSwapper(address account);\n\n  /**\n   * @notice Thrown when trying to remove an account from the supplementary allowance target list,\n   *         when it wasn't there before\n   */\n  error AccountIsNotSupplementaryAllowanceTarget(address account);\n\n  /// @notice Thrown when trying to mark an account as swapper or allowance target, but it already has a role assigned\n  error AccountAlreadyHasRole(address account);\n\n  /**\n   * @notice Emitted when swappers are removed from the allowlist\n   * @param swappers The swappers that were removed\n   */\n  event RemoveSwappersFromAllowlist(address[] swappers);\n\n  /**\n   * @notice Emitted when new swappers are added to the allowlist\n   * @param swappers The swappers that were added\n   */\n  event AllowedSwappers(address[] swappers);\n\n  /**\n   * @notice Emitted when new supplementary allowance targets are are added to the allowlist\n   * @param allowanceTargets The allowance targets that were added\n   */\n  event AllowedSupplementaryAllowanceTargets(address[] allowanceTargets);\n\n  /**\n   * @notice Emitted when supplementary allowance targets are removed from the allowlist\n   * @param allowanceTargets The allowance targets that were removed\n   */\n  event RemovedAllowanceTargetsFromAllowlist(address[] allowanceTargets);\n\n  /**\n   * @notice Returns whether a given account is allowlisted for swaps\n   * @param account The address to check\n   * @return Whether it is allowlisted for swaps\n   */\n  function isSwapperAllowlisted(address account) external view returns (bool);\n\n  /**\n   * @notice Returns whether a given account is a valid allowance target. This would be true\n   *         if the account is either a swapper, or a supplementary allowance target\n   * @param account The address to check\n   * @return Whether it is a valid allowance target\n   */\n  function isValidAllowanceTarget(address account) external view returns (bool);\n\n  /**\n   * @notice Adds a list of swappers to the allowlist\n   * @dev Can only be called by users with the admin role\n   * @param swappers The list of swappers to add\n   */\n  function allowSwappers(address[] calldata swappers) external;\n\n  /**\n   * @notice Removes the given swappers from the allowlist\n   * @dev Can only be called by users with the admin role\n   * @param swappers The list of swappers to remove\n   */\n  function removeSwappersFromAllowlist(address[] calldata swappers) external;\n\n  /**\n   * @notice Adds a list of supplementary allowance targets to the allowlist\n   * @dev Can only be called by users with the admin role\n   * @param allowanceTargets The list of allowance targets to add\n   */\n  function allowSupplementaryAllowanceTargets(address[] calldata allowanceTargets) external;\n\n  /**\n   * @notice Removes the given allowance targets from the allowlist\n   * @dev Can only be called by users with the admin role\n   * @param allowanceTargets The list of allowance targets to remove\n   */\n  function removeSupplementaryAllowanceTargetsFromAllowlist(address[] calldata allowanceTargets) external;\n}\n"
    },
    "contracts/mocks/DCAFeeManager/DCAFeeManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../../DCAFeeManager/DCAFeeManager.sol';\n\ncontract DCAFeeManagerMock is DCAFeeManager {\n  struct SendToRecipientCall {\n    address token;\n    uint256 amount;\n    address recipient;\n  }\n\n  struct SendBalanceOnContractToRecipientCall {\n    address token;\n    address recipient;\n  }\n\n  SendToRecipientCall[] internal _sendToRecipientCalls;\n  SendBalanceOnContractToRecipientCall[] internal _sendBalanceOnContractToRecipientCalls;\n  RevokeAction[][] internal _revokeCalls;\n\n  constructor(address _superAdmin, address[] memory _initialAdmins) DCAFeeManager(_superAdmin, _initialAdmins) {}\n\n  function sendBalanceOnContractToRecipientCalls() external view returns (SendBalanceOnContractToRecipientCall[] memory) {\n    return _sendBalanceOnContractToRecipientCalls;\n  }\n\n  function sendToRecipientCalls() external view returns (SendToRecipientCall[] memory) {\n    return _sendToRecipientCalls;\n  }\n\n  function revokeAllowancesCalls() external view returns (RevokeAction[][] memory) {\n    return _revokeCalls;\n  }\n\n  function setPosition(\n    address _from,\n    address _to,\n    uint256 _positionId\n  ) external {\n    positions[getPositionKey(_from, _to)] = _positionId;\n  }\n\n  function positionsWithToken(address _toToken) external view returns (uint256[] memory) {\n    return _positionsWithToken[_toToken];\n  }\n\n  function setPositionsWithToken(address _toToken, uint256[] calldata _positionIds) external {\n    for (uint256 i; i < _positionIds.length; i++) {\n      _positionsWithToken[_toToken].push(_positionIds[i]);\n    }\n  }\n\n  function _sendBalanceOnContractToRecipient(address _token, address _recipient) internal override {\n    _sendBalanceOnContractToRecipientCalls.push(SendBalanceOnContractToRecipientCall(_token, _recipient));\n  }\n\n  function _sendToRecipient(\n    address _token,\n    uint256 _amount,\n    address _recipient\n  ) internal override {\n    _sendToRecipientCalls.push(SendToRecipientCall(_token, _amount, _recipient));\n  }\n\n  function _revokeAllowances(RevokeAction[] calldata _revokeActions) internal override {\n    _revokeCalls.push();\n    uint256 _currentCall = _revokeCalls.length - 1;\n    for (uint256 i; i < _revokeActions.length; i++) {\n      _revokeCalls[_currentCall].push(_revokeActions[i]);\n    }\n  }\n}\n"
    },
    "@mean-finance/swappers/solidity/contracts/extensions/RevokableWithGovernor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../utils/Governable.sol';\nimport '../SwapAdapter.sol';\n\nabstract contract RevokableWithGovernor is SwapAdapter, Governable {\n  /**\n   * @notice Revokes ERC20 allowances for the given spenders\n   * @dev Can only be called by the governor\n   * @param _revokeActions The spenders and tokens to revoke\n   */\n  function revokeAllowances(RevokeAction[] calldata _revokeActions) external onlyGovernor {\n    _revokeAllowances(_revokeActions);\n  }\n}\n"
    },
    "@mean-finance/swappers/solidity/contracts/utils/Governable.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../../interfaces/utils/IGovernable.sol';\n\n/**\n * @notice This contract is meant to be used in other contracts. By using this contract,\n *         a specific address will be given a \"governor\" role, which basically will be able to\n *         control certains aspects of the contract. There are other contracts that do the same,\n *         but this contract forces a new governor to accept the role before it's transferred.\n *         This is a basically a safety measure to prevent losing access to the contract.\n */\nabstract contract Governable is IGovernable {\n  /// @inheritdoc IGovernable\n  address public governor;\n\n  /// @inheritdoc IGovernable\n  address public pendingGovernor;\n\n  constructor(address _governor) {\n    if (_governor == address(0)) revert GovernorIsZeroAddress();\n    governor = _governor;\n  }\n\n  /// @inheritdoc IGovernable\n  function isGovernor(address _account) public view returns (bool) {\n    return _account == governor;\n  }\n\n  /// @inheritdoc IGovernable\n  function isPendingGovernor(address _account) public view returns (bool) {\n    return _account == pendingGovernor;\n  }\n\n  /// @inheritdoc IGovernable\n  function setPendingGovernor(address _pendingGovernor) external onlyGovernor {\n    pendingGovernor = _pendingGovernor;\n    emit PendingGovernorSet(_pendingGovernor);\n  }\n\n  /// @inheritdoc IGovernable\n  function acceptPendingGovernor() external onlyPendingGovernor {\n    governor = pendingGovernor;\n    pendingGovernor = address(0);\n    emit PendingGovernorAccepted();\n  }\n\n  modifier onlyGovernor() {\n    if (!isGovernor(msg.sender)) revert OnlyGovernor();\n    _;\n  }\n\n  modifier onlyPendingGovernor() {\n    if (!isPendingGovernor(msg.sender)) revert OnlyPendingGovernor();\n    _;\n  }\n}\n"
    },
    "@mean-finance/swappers/solidity/interfaces/utils/IGovernable.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\n/**\n * @title A contract that manages a \"governor\" role\n */\ninterface IGovernable {\n  /// @notice Thrown when trying to set the zero address as governor\n  error GovernorIsZeroAddress();\n\n  /// @notice Thrown when trying to execute an action that only the governor an execute\n  error OnlyGovernor();\n\n  /// @notice Thrown when trying to execute an action that only the pending governor an execute\n  error OnlyPendingGovernor();\n\n  /**\n   * @notice Emitted when a new pending governor is set\n   * @param newPendingGovernor The new pending governor\n   */\n  event PendingGovernorSet(address newPendingGovernor);\n\n  /**\n   * @notice Emitted when the pending governor accepts the role and becomes the governor\n   */\n  event PendingGovernorAccepted();\n\n  /**\n   * @notice Returns the address of the governor\n   * @return The address of the governor\n   */\n  function governor() external view returns (address);\n\n  /**\n   * @notice Returns the address of the pending governor\n   * @return The address of the pending governor\n   */\n  function pendingGovernor() external view returns (address);\n\n  /**\n   * @notice Returns whether the given account is the current governor\n   * @param account The account to check\n   * @return Whether it is the current governor or not\n   */\n  function isGovernor(address account) external view returns (bool);\n\n  /**\n   * @notice Returns whether the given account is the pending governor\n   * @param account The account to check\n   * @return Whether it is the pending governor or not\n   */\n  function isPendingGovernor(address account) external view returns (bool);\n\n  /**\n   * @notice Sets a new pending governor\n   * @dev Only the current governor can execute this action\n   * @param pendingGovernor The new pending governor\n   */\n  function setPendingGovernor(address pendingGovernor) external;\n\n  /**\n   * @notice Sets the pending governor as the governor\n   * @dev Only the pending governor can execute this action\n   */\n  function acceptPendingGovernor() external;\n}\n"
    },
    "contracts/utils/BaseCompanion.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@mean-finance/swappers/solidity/contracts/extensions/RevokableWithGovernor.sol';\nimport '@mean-finance/swappers/solidity/contracts/extensions/PayableMulticall.sol';\nimport {SimulationAdapter} from '@mean-finance/call-simulation/contracts/SimulationAdapter.sol';\nimport {IPermit2} from '../interfaces/external/IPermit2.sol';\nimport {Permit2Transfers} from '../libraries/Permit2Transfers.sol';\n\n/**\n * @notice This contract will work as base companion for all our contracts. It will extend the capabilities of our companion\n *         contracts so that they can execute multicalls, swaps, revokes and more\n * @dev All public functions are payable, so that they can be multicalled together with other payable functions when msg.value > 0\n */\nabstract contract BaseCompanion is SimulationAdapter, RevokableWithGovernor, PayableMulticall {\n  using Permit2Transfers for IPermit2;\n  using SafeERC20 for IERC20;\n\n  /**\n   * @notice Thrown when the swap produced less token out than expected\n   * @param received The amount of token out received\n   * @param expected The amount of token out expected\n   */\n  error ReceivedTooLittleTokenOut(uint256 received, uint256 expected);\n\n  /**\n   * @notice Returns the address of the Permit2 contract\n   * @dev This value is constant and cannot change\n   * @return The address of the Permit2 contract\n   */\n  // solhint-disable-next-line var-name-mixedcase\n  IPermit2 public immutable PERMIT2;\n\n  /// @notice The address of the swapper\n  address public swapper;\n\n  /// @notice The address of the allowance target\n  address public allowanceTarget;\n\n  constructor(\n    address _swapper,\n    address _allowanceTarget,\n    address _governor,\n    IPermit2 _permit2\n  ) SwapAdapter(address(1)) Governable(_governor) {\n    swapper = _swapper;\n    allowanceTarget = _allowanceTarget;\n    PERMIT2 = _permit2;\n  }\n\n  /**\n   * @notice Sends the specified amount of the given token to the recipient\n   * @param _token The token to transfer\n   * @param _amount The amount to transfer\n   * @param _recipient The recipient of the token balance\n   */\n  function sendToRecipient(\n    address _token,\n    uint256 _amount,\n    address _recipient\n  ) external payable {\n    _sendToRecipient(_token, _amount, _recipient);\n  }\n\n  /**\n   * @notice Takes the given amount of tokens from the caller and transfers it to this contract\n   * @param _token The token to take\n   * @param _amount The amount to take\n   */\n  function takeFromCaller(\n    IERC20 _token,\n    uint256 _amount,\n    address _recipient\n  ) external payable {\n    _token.safeTransferFrom(msg.sender, _recipient, _amount);\n  }\n\n  /**\n   * @notice Executes a swap against the swapper\n   * @param _allowanceToken The token to set allowance for (can be set to zero address to ignore)\n   * @param _value The value to send to the swapper as part of the swap\n   * @param _swapData The swap data\n   * @param _tokenOut The token that will be bought as part of the swap\n   * @param _minTokenOut The min amount of token out that we expect\n   */\n  function runSwap(\n    address _allowanceToken,\n    uint256 _value,\n    bytes calldata _swapData,\n    address _tokenOut,\n    uint256 _minTokenOut\n  ) external payable returns (uint256 _amountOut) {\n    if (_allowanceToken != address(0)) {\n      IERC20(_allowanceToken).approve(allowanceTarget, type(uint256).max);\n    }\n\n    _executeSwap(swapper, _swapData, _value);\n\n    _amountOut = _tokenOut == PROTOCOL_TOKEN ? address(this).balance : IERC20(_tokenOut).balanceOf(address(this));\n    if (_amountOut < _minTokenOut) revert ReceivedTooLittleTokenOut(_amountOut, _minTokenOut);\n  }\n\n  /**\n   * @notice Takes the given amount of tokens from the caller with Permit2 and transfers it to this contract\n   * @param _token The token to take\n   * @param _amount The amount to take\n   * @param _nonce The signed nonce\n   * @param _deadline The signature's deadline\n   * @param _signature The owner's signature\n   * @param _recipient The address that will receive the funds\n   */\n  function permitTakeFromCaller(\n    address _token,\n    uint256 _amount,\n    uint256 _nonce,\n    uint256 _deadline,\n    bytes calldata _signature,\n    address _recipient\n  ) external payable {\n    PERMIT2.takeFromCaller(_token, _amount, _nonce, _deadline, _signature, _recipient);\n  }\n\n  /**\n   * @notice Takes the a batch of tokens from the caller with Permit2 and transfers it to this contract\n   * @param _tokens The tokens to take\n   * @param _nonce The signed nonce\n   * @param _deadline The signature's deadline\n   * @param _signature The owner's signature\n   * @param _recipient The address that will receive the funds\n   */\n  function batchPermitTakeFromCaller(\n    IPermit2.TokenPermissions[] calldata _tokens,\n    uint256 _nonce,\n    uint256 _deadline,\n    bytes calldata _signature,\n    address _recipient\n  ) external payable {\n    PERMIT2.batchTakeFromCaller(_tokens, _nonce, _deadline, _signature, _recipient);\n  }\n\n  /**\n   * @notice Checks if the contract has any balance of the given token, and if it does,\n   *         it sends it to the given recipient\n   * @param _token The token to check\n   * @param _recipient The recipient of the token balance\n   */\n  function sendBalanceOnContractToRecipient(address _token, address _recipient) external payable {\n    _sendBalanceOnContractToRecipient(_token, _recipient);\n  }\n\n  /**\n   * @notice Sets a new swapper and allowance target\n   * @param _newSwapper The address of the new swapper\n   * @param _newAllowanceTarget The address of the new allowance target\n   */\n  function setSwapper(address _newSwapper, address _newAllowanceTarget) external onlyGovernor {\n    swapper = _newSwapper;\n    allowanceTarget = _newAllowanceTarget;\n  }\n}\n"
    },
    "@mean-finance/swappers/solidity/contracts/extensions/PayableMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\n/**\n * @dev Adding this contract will enable batching calls. This is basically the same as Open Zeppelin's\n *      Multicall contract, but we have made it payable. It supports both payable and non payable\n *      functions. However, if `msg.value` is not zero, then non payable functions cannot be called.\n *      Any contract that uses this Multicall version should be very careful when using msg.value.\n *      For more context, read: https://github.com/Uniswap/v3-periphery/issues/52\n */\nabstract contract PayableMulticall {\n  /**\n   * @notice Receives and executes a batch of function calls on this contract.\n   * @param _data A list of different function calls to execute\n   * @return _results The result of executing each of those calls\n   */\n  function multicall(bytes[] calldata _data) external payable returns (bytes[] memory _results) {\n    _results = new bytes[](_data.length);\n    for (uint256 i = 0; i < _data.length; ) {\n      _results[i] = Address.functionDelegateCall(address(this), _data[i]);\n      unchecked {\n        i++;\n      }\n    }\n    return _results;\n  }\n}\n"
    },
    "@mean-finance/call-simulation/contracts/SimulationAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC165 } from \"./interfaces/external/IERC165.sol\";\nimport { ISimulationAdapter } from \"./interfaces/ISimulationAdapter.sol\";\n\n/**\n * @title Simulation Adapter\n * @author Sam Bugs\n * @notice This contracts adds off-chain simulation capabilities to existing contracts. It works similarly to a\n *         multicall, but the state is not modified in each subcall.\n */\nabstract contract SimulationAdapter is IERC165, ISimulationAdapter {\n  /// @notice An error that contains a simulation's result\n  error SimulatedCall(SimulationResult result);\n\n  /// @inheritdoc IERC165\n  function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n    return _interfaceId == type(ISimulationAdapter).interfaceId || _interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc ISimulationAdapter\n  function simulate(bytes[] calldata _calls) external payable returns (SimulationResult[] memory _results) {\n    _results = new SimulationResult[](_calls.length);\n    for (uint256 i = 0; i < _calls.length; i++) {\n      _results[i] = _simulate(_calls[i]);\n    }\n    return _results;\n  }\n\n  /**\n   * @notice Executes a simulation and returns the result\n   * @param _call The call to simulate\n   * @return _simulationResult The simulation's result\n   */\n  function _simulate(bytes calldata _call) internal returns (SimulationResult memory _simulationResult) {\n    (bool _success, bytes memory _result) =\n    // solhint-disable-next-line avoid-low-level-calls\n     address(this).delegatecall(abi.encodeWithSelector(this.simulateAndRevert.selector, _call));\n    require(!_success, \"WTF? Should have failed!\");\n    // Move pointer to ignore selector\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      _result := add(_result, 0x04)\n    }\n    (_simulationResult) = abi.decode(_result, (SimulationResult));\n  }\n\n  /**\n   * @notice Executes a call agains this contract and reverts with the result\n   * @dev This is meant to be used internally, do not call!\n   * @param _call The call to simulate\n   */\n  function simulateAndRevert(bytes calldata _call) external payable {\n    uint256 _gasAtStart = gasleft();\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool _success, bytes memory _result) = address(this).delegatecall(_call);\n    uint256 _gasSpent = _gasAtStart - gasleft();\n    revert SimulatedCall(SimulationResult({ success: _success, result: _result, gasSpent: _gasSpent }));\n  }\n}\n"
    },
    "contracts/interfaces/external/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\n// Minimal Permit2 interface, derived from\n// https://github.com/Uniswap/permit2/blob/main/src/interfaces/ISignatureTransfer.sol\ninterface IPermit2 {\n  struct TokenPermissions {\n    address token;\n    uint256 amount;\n  }\n\n  struct PermitTransferFrom {\n    TokenPermissions permitted;\n    uint256 nonce;\n    uint256 deadline;\n  }\n\n  struct PermitBatchTransferFrom {\n    TokenPermissions[] permitted;\n    uint256 nonce;\n    uint256 deadline;\n  }\n\n  struct SignatureTransferDetails {\n    address to;\n    uint256 requestedAmount;\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function permitTransferFrom(\n    PermitTransferFrom calldata permit,\n    SignatureTransferDetails calldata transferDetails,\n    address owner,\n    bytes calldata signature\n  ) external;\n\n  function permitTransferFrom(\n    PermitBatchTransferFrom memory permit,\n    SignatureTransferDetails[] calldata transferDetails,\n    address owner,\n    bytes calldata signature\n  ) external;\n}\n"
    },
    "contracts/libraries/Permit2Transfers.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport {IPermit2} from '../interfaces/external/IPermit2.sol';\n\n/**\n * @title Permit2 Transfers Library\n * @author Sam Bugs\n * @notice A small library to call Permit2's transfer from methods\n */\nlibrary Permit2Transfers {\n  /**\n   * @notice Executes a transfer from using Permit2\n   * @param _permit2 The Permit2 contract\n   * @param _token The token to transfer\n   * @param _amount The amount to transfer\n   * @param _nonce The owner's nonce\n   * @param _deadline The signature's expiration deadline\n   * @param _signature The signature that allows the transfer\n   * @param _recipient The address that will receive the funds\n   */\n  function takeFromCaller(\n    IPermit2 _permit2,\n    address _token,\n    uint256 _amount,\n    uint256 _nonce,\n    uint256 _deadline,\n    bytes calldata _signature,\n    address _recipient\n  ) internal {\n    _permit2.permitTransferFrom(\n      // The permit message.\n      IPermit2.PermitTransferFrom({permitted: IPermit2.TokenPermissions({token: _token, amount: _amount}), nonce: _nonce, deadline: _deadline}),\n      // The transfer recipient and amount.\n      IPermit2.SignatureTransferDetails({to: _recipient, requestedAmount: _amount}),\n      // The owner of the tokens, which must also be\n      // the signer of the message, otherwise this call\n      // will fail.\n      msg.sender,\n      // The packed signature that was the result of signing\n      // the EIP712 hash of `permit`.\n      _signature\n    );\n  }\n\n  /**\n   * @notice Executes a batch transfer from using Permit2\n   * @param _permit2 The Permit2 contract\n   * @param _tokens The amount of tokens to transfer\n   * @param _nonce The owner's nonce\n   * @param _deadline The signature's expiration deadline\n   * @param _signature The signature that allows the transfer\n   * @param _recipient The address that will receive the funds\n   */\n  function batchTakeFromCaller(\n    IPermit2 _permit2,\n    IPermit2.TokenPermissions[] calldata _tokens,\n    uint256 _nonce,\n    uint256 _deadline,\n    bytes calldata _signature,\n    address _recipient\n  ) internal {\n    if (_tokens.length > 0) {\n      _permit2.permitTransferFrom(\n        // The permit message.\n        IPermit2.PermitBatchTransferFrom({permitted: _tokens, nonce: _nonce, deadline: _deadline}),\n        // The transfer recipients and amounts.\n        _buildTransferDetails(_tokens, _recipient),\n        // The owner of the tokens, which must also be\n        // the signer of the message, otherwise this call\n        // will fail.\n        msg.sender,\n        // The packed signature that was the result of signing\n        // the EIP712 hash of `permit`.\n        _signature\n      );\n    }\n  }\n\n  function _buildTransferDetails(IPermit2.TokenPermissions[] calldata _tokens, address _recipient)\n    private\n    pure\n    returns (IPermit2.SignatureTransferDetails[] memory _details)\n  {\n    _details = new IPermit2.SignatureTransferDetails[](_tokens.length);\n    for (uint256 i; i < _details.length; ) {\n      _details[i] = IPermit2.SignatureTransferDetails({to: _recipient, requestedAmount: _tokens[i].amount});\n      unchecked {\n        ++i;\n      }\n    }\n  }\n}\n"
    },
    "@mean-finance/call-simulation/contracts/interfaces/external/IERC165.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@mean-finance/call-simulation/contracts/interfaces/ISimulationAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\ninterface ISimulationAdapter {\n  /// @notice A simulation's result\n  struct SimulationResult {\n    bool success;\n    bytes result;\n    uint256 gasSpent;\n  }\n\n  /**\n   * @notice Executes individual simulations against this contract but doesn't modify the state when doing so\n   * @dev This function is meant to be used for off-chain simulation and should not be called on-chain\n   * @param calls The calls to simulate\n   * @return results Each simulation result\n   */\n  function simulate(bytes[] calldata calls) external payable returns (SimulationResult[] memory results);\n}\n"
    },
    "contracts/mocks/utils/BaseCompanion.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../../utils/BaseCompanion.sol';\n\ncontract BaseCompanionMock is BaseCompanion {\n  constructor(\n    address _swapper,\n    address _allowanceTarget,\n    address _governor,\n    IPermit2 _permit2\n  ) BaseCompanion(_swapper, _allowanceTarget, _governor, _permit2) {}\n\n  struct TakeFromMsgSenderCall {\n    IERC20 token;\n    uint256 amount;\n  }\n\n  struct SendBalanceOnContractToRecipientCall {\n    address token;\n    address recipient;\n  }\n\n  struct SendToRecipientCall {\n    address token;\n    uint256 amount;\n    address recipient;\n  }\n\n  TakeFromMsgSenderCall[] internal _takeFromMsgSenderCalls;\n  SendBalanceOnContractToRecipientCall[] internal _sendBalanceOnContractToRecipientCalls;\n  SendToRecipientCall[] internal _sendToRecipientCalls;\n\n  function takeFromMsgSenderCalls() external view returns (TakeFromMsgSenderCall[] memory) {\n    return _takeFromMsgSenderCalls;\n  }\n\n  function sendBalanceOnContractToRecipientCalls() external view returns (SendBalanceOnContractToRecipientCall[] memory) {\n    return _sendBalanceOnContractToRecipientCalls;\n  }\n\n  function sendToRecipientCalls() external view returns (SendToRecipientCall[] memory) {\n    return _sendToRecipientCalls;\n  }\n\n  function _takeFromMsgSender(IERC20 _token, uint256 _amount) internal override {\n    _takeFromMsgSenderCalls.push(TakeFromMsgSenderCall(_token, _amount));\n    super._takeFromMsgSender(_token, _amount);\n  }\n\n  function _sendBalanceOnContractToRecipient(address _token, address _recipient) internal override {\n    _sendBalanceOnContractToRecipientCalls.push(SendBalanceOnContractToRecipientCall(_token, _recipient));\n    super._sendBalanceOnContractToRecipient(_token, _recipient);\n  }\n\n  function _sendToRecipient(\n    address _token,\n    uint256 _amount,\n    address _recipient\n  ) internal override {\n    _sendToRecipientCalls.push(SendToRecipientCall(_token, _amount, _recipient));\n    super._sendToRecipient(_token, _amount, _recipient);\n  }\n}\n"
    },
    "contracts/DCAKeep3rJob/DCAKeep3rJob.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport '@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol';\nimport '../interfaces/IDCAKeep3rJob.sol';\n\ncontract DCAKeep3rJob is AccessControl, EIP712, IDCAKeep3rJob {\n  using Address for address;\n\n  bytes32 public constant SUPER_ADMIN_ROLE = keccak256('SUPER_ADMIN_ROLE');\n  bytes32 public constant CAN_SIGN_ROLE = keccak256('CAN_SIGN_ROLE');\n  bytes32 public constant WORK_TYPEHASH = keccak256('Work(address swapper,bytes data,uint256 nonce)');\n\n  /// @inheritdoc IDCAKeep3rJob\n  IKeep3r public immutable keep3r;\n  /// @inheritdoc IDCAKeep3rJob\n  SwapperAndNonce public swapperAndNonce; // Note: data grouped in struct to reduce SLOADs\n\n  constructor(\n    IKeep3r _keep3r,\n    address _swapper,\n    address _superAdmin,\n    address[] memory _initialCanSign\n  ) EIP712('Mean Finance - DCA Keep3r Job', '1') {\n    if (address(_keep3r) == address(0)) revert ZeroAddress();\n    if (_swapper == address(0)) revert ZeroAddress();\n    if (_superAdmin == address(0)) revert ZeroAddress();\n\n    keep3r = _keep3r;\n    swapperAndNonce.swapper = _swapper;\n\n    // We are setting the super admin role as its own admin so we can transfer it\n    _setRoleAdmin(SUPER_ADMIN_ROLE, SUPER_ADMIN_ROLE);\n    _setRoleAdmin(CAN_SIGN_ROLE, SUPER_ADMIN_ROLE);\n    _setupRole(SUPER_ADMIN_ROLE, _superAdmin);\n\n    for (uint256 i = 0; i < _initialCanSign.length; ) {\n      _setupRole(CAN_SIGN_ROLE, _initialCanSign[i]);\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /// @inheritdoc IDCAKeep3rJob\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /// @inheritdoc IDCAKeep3rJob\n  function setSwapper(address _swapper) external onlyRole(SUPER_ADMIN_ROLE) {\n    if (address(_swapper) == address(0)) revert ZeroAddress();\n    swapperAndNonce.swapper = _swapper;\n    emit NewSwapperSet(_swapper);\n  }\n\n  /// @inheritdoc IDCAKeep3rJob\n  function work(\n    bytes calldata _call,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external {\n    if (!keep3r.isKeeper(msg.sender)) revert NotAKeeper();\n\n    SwapperAndNonce memory _swapperAndNonce = swapperAndNonce;\n    bytes32 _structHash = keccak256(abi.encode(WORK_TYPEHASH, _swapperAndNonce.swapper, keccak256(_call), _swapperAndNonce.nonce));\n    bytes32 _hash = _hashTypedDataV4(_structHash);\n    address _signer = ECDSA.recover(_hash, _v, _r, _s);\n    if (!hasRole(CAN_SIGN_ROLE, _signer)) revert SignerCannotSignWork();\n\n    swapperAndNonce.nonce = _swapperAndNonce.nonce + 1;\n    _swapperAndNonce.swapper.functionCall(_call);\n\n    keep3r.worked(msg.sender);\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "contracts/interfaces/IDCAKeep3rJob.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport 'keep3r-v2/solidity/interfaces/IKeep3r.sol';\n\ninterface IDCAKeep3rJob {\n  /// @notice A struct that contains the swapper and nonce to use\n  struct SwapperAndNonce {\n    address swapper;\n    uint96 nonce;\n  }\n\n  /// @notice Thrown when one of the parameters is a zero address\n  error ZeroAddress();\n\n  /// @notice Thrown when a user tries to execute work but the signature is invalid\n  error SignerCannotSignWork();\n\n  /// @notice Thrown when a non keep3r address tries to execute work\n  error NotAKeeper();\n\n  /**\n   * @notice Emitted when a new swapper is set\n   * @param newSwapper The new swapper\n   */\n  event NewSwapperSet(address newSwapper);\n\n  /**\n   * @notice The domain separator used for the work signature\n   * @return The domain separator used for the work signature\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice Returns the swapper address\n   * @return swapper The swapper's address\n   * @return nonce The next nonce to use\n   */\n  function swapperAndNonce() external returns (address swapper, uint96 nonce);\n\n  /**\n   * @notice Returns the Keep3r address\n   * @return The Keep3r address address\n   */\n  function keep3r() external returns (IKeep3r);\n\n  /**\n   * @notice Sets a new swapper address\n   * @dev Will revert with ZeroAddress if the zero address is passed\n   *      Can only be called by an admin\n   * @param swapper The new swapper address\n   */\n  function setSwapper(address swapper) external;\n\n  /**\n   * @notice Takes an encoded call and executes it against the swapper\n   * @dev Will revert with:\n   *      - NotAKeeper if the caller is not a keep3r\n   *      - SignerCannotSignWork if the address who signed the message cannot sign work\n   * @param call The call to execut against the swapper\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n   */\n  function work(\n    bytes calldata call,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "keep3r-v2/solidity/interfaces/IKeep3r.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './peripherals/IKeep3rJobs.sol';\nimport './peripherals/IKeep3rKeepers.sol';\nimport './peripherals/IKeep3rAccountance.sol';\nimport './peripherals/IKeep3rRoles.sol';\nimport './peripherals/IKeep3rParameters.sol';\n\n// solhint-disable-next-line no-empty-blocks\n\n/// @title Keep3rV2 contract\n/// @notice This contract inherits all the functionality of Keep3rV2\ninterface IKeep3r is IKeep3rJobs, IKeep3rKeepers, IKeep3rAccountance, IKeep3rRoles, IKeep3rParameters {\n\n}\n"
    },
    "keep3r-v2/solidity/interfaces/peripherals/IKeep3rJobs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\n/// @title Keep3rJobFundableCredits contract\n/// @notice Handles the addition and withdrawal of credits from a job\ninterface IKeep3rJobFundableCredits {\n  // Events\n\n  /// @notice Emitted when Keep3rJobFundableCredits#addTokenCreditsToJob is called\n  /// @param _job The address of the job being credited\n  /// @param _token The address of the token being provided\n  /// @param _provider The user that calls the function\n  /// @param _amount The amount of credit being added to the job\n  event TokenCreditAddition(address indexed _job, address indexed _token, address indexed _provider, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobFundableCredits#withdrawTokenCreditsFromJob is called\n  /// @param _job The address of the job from which the credits are withdrawn\n  /// @param _token The credit being withdrawn from the job\n  /// @param _receiver The user that receives the tokens\n  /// @param _amount The amount of credit withdrawn\n  event TokenCreditWithdrawal(address indexed _job, address indexed _token, address indexed _receiver, uint256 _amount);\n\n  // Errors\n\n  /// @notice Throws when the token is KP3R, as it should not be used for direct token payments\n  error TokenUnallowed();\n\n  /// @notice Throws when the token withdraw cooldown has not yet passed\n  error JobTokenCreditsLocked();\n\n  /// @notice Throws when the user tries to withdraw more tokens than it has\n  error InsufficientJobTokenCredits();\n\n  // Variables\n\n  /// @notice Last block where tokens were added to the job [job => token => timestamp]\n  /// @return _timestamp The last block where tokens were added to the job\n  function jobTokenCreditsAddedAt(address _job, address _token) external view returns (uint256 _timestamp);\n\n  // Methods\n\n  /// @notice Add credit to a job to be paid out for work\n  /// @param _job The address of the job being credited\n  /// @param _token The address of the token being credited\n  /// @param _amount The amount of credit being added\n  function addTokenCreditsToJob(\n    address _job,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  /// @notice Withdraw credit from a job\n  /// @param _job The address of the job from which the credits are withdrawn\n  /// @param _token The address of the token being withdrawn\n  /// @param _amount The amount of token to be withdrawn\n  /// @param _receiver The user that will receive tokens\n  function withdrawTokenCreditsFromJob(\n    address _job,\n    address _token,\n    uint256 _amount,\n    address _receiver\n  ) external;\n}\n\n/// @title  Keep3rJobFundableLiquidity contract\n/// @notice Handles the funding of jobs through specific liquidity pairs\ninterface IKeep3rJobFundableLiquidity {\n  // Events\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#approveLiquidity function is called\n  /// @param _liquidity The address of the liquidity pair being approved\n  event LiquidityApproval(address _liquidity);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#revokeLiquidity function is called\n  /// @param _liquidity The address of the liquidity pair being revoked\n  event LiquidityRevocation(address _liquidity);\n\n  /// @notice Emitted when IKeep3rJobFundableLiquidity#addLiquidityToJob function is called\n  /// @param _job The address of the job to which liquidity will be added\n  /// @param _liquidity The address of the liquidity being added\n  /// @param _provider The user that calls the function\n  /// @param _amount The amount of liquidity being added\n  event LiquidityAddition(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _amount);\n\n  /// @notice Emitted when IKeep3rJobFundableLiquidity#withdrawLiquidityFromJob function is called\n  /// @param _job The address of the job of which liquidity will be withdrawn from\n  /// @param _liquidity The address of the liquidity being withdrawn\n  /// @param _receiver The receiver of the liquidity tokens\n  /// @param _amount The amount of liquidity being withdrawn from the job\n  event LiquidityWithdrawal(address indexed _job, address indexed _liquidity, address indexed _receiver, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#addLiquidityToJob function is called\n  /// @param _job The address of the job whose credits will be updated\n  /// @param _rewardedAt The time at which the job was last rewarded\n  /// @param _currentCredits The current credits of the job\n  /// @param _periodCredits The credits of the job for the current period\n  event LiquidityCreditsReward(address indexed _job, uint256 _rewardedAt, uint256 _currentCredits, uint256 _periodCredits);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#forceLiquidityCreditsToJob function is called\n  /// @param _job The address of the job whose credits will be updated\n  /// @param _rewardedAt The time at which the job was last rewarded\n  /// @param _currentCredits The current credits of the job\n  event LiquidityCreditsForced(address indexed _job, uint256 _rewardedAt, uint256 _currentCredits);\n\n  // Errors\n\n  /// @notice Throws when the liquidity being approved has already been approved\n  error LiquidityPairApproved();\n\n  /// @notice Throws when the liquidity being removed has not been approved\n  error LiquidityPairUnexistent();\n\n  /// @notice Throws when trying to add liquidity to an unapproved pool\n  error LiquidityPairUnapproved();\n\n  /// @notice Throws when the job doesn't have the requested liquidity\n  error JobLiquidityUnexistent();\n\n  /// @notice Throws when trying to remove more liquidity than the job has\n  error JobLiquidityInsufficient();\n\n  /// @notice Throws when trying to add less liquidity than the minimum liquidity required\n  error JobLiquidityLessThanMin();\n\n  // Structs\n\n  /// @notice Stores the tick information of the different liquidity pairs\n  struct TickCache {\n    int56 current; // Tracks the current tick\n    int56 difference; // Stores the difference between the current tick and the last tick\n    uint256 period; // Stores the period at which the last observation was made\n  }\n\n  // Variables\n\n  /// @notice Lists liquidity pairs\n  /// @return _list An array of addresses with all the approved liquidity pairs\n  function approvedLiquidities() external view returns (address[] memory _list);\n\n  /// @notice Amount of liquidity in a specified job\n  /// @param _job The address of the job being checked\n  /// @param _liquidity The address of the liquidity we are checking\n  /// @return _amount Amount of liquidity in the specified job\n  function liquidityAmount(address _job, address _liquidity) external view returns (uint256 _amount);\n\n  /// @notice Last time the job was rewarded liquidity credits\n  /// @param _job The address of the job being checked\n  /// @return _timestamp Timestamp of the last time the job was rewarded liquidity credits\n  function rewardedAt(address _job) external view returns (uint256 _timestamp);\n\n  /// @notice Last time the job was worked\n  /// @param _job The address of the job being checked\n  /// @return _timestamp Timestamp of the last time the job was worked\n  function workedAt(address _job) external view returns (uint256 _timestamp);\n\n  // Methods\n\n  /// @notice Returns the liquidity credits of a given job\n  /// @param _job The address of the job of which we want to know the liquidity credits\n  /// @return _amount The liquidity credits of a given job\n  function jobLiquidityCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Returns the credits of a given job for the current period\n  /// @param _job The address of the job of which we want to know the period credits\n  /// @return _amount The credits the given job has at the current period\n  function jobPeriodCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Calculates the total credits of a given job\n  /// @param _job The address of the job of which we want to know the total credits\n  /// @return _amount The total credits of the given job\n  function totalJobCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Calculates how many credits should be rewarded periodically for a given liquidity amount\n  /// @dev _periodCredits = underlying KP3Rs for given liquidity amount * rewardPeriod / inflationPeriod\n  /// @param _liquidity The liquidity to provide\n  /// @param _amount The amount of liquidity to provide\n  /// @return _periodCredits The amount of KP3R periodically minted for the given liquidity\n  function quoteLiquidity(address _liquidity, uint256 _amount) external view returns (uint256 _periodCredits);\n\n  /// @notice Observes the current state of the liquidity pair being observed and updates TickCache with the information\n  /// @param _liquidity The liquidity pair being observed\n  /// @return _tickCache The updated TickCache\n  function observeLiquidity(address _liquidity) external view returns (TickCache memory _tickCache);\n\n  /// @notice Gifts liquidity credits to the specified job\n  /// @param _job The address of the job being credited\n  /// @param _amount The amount of liquidity credits to gift\n  function forceLiquidityCreditsToJob(address _job, uint256 _amount) external;\n\n  /// @notice Approve a liquidity pair for being accepted in future\n  /// @param _liquidity The address of the liquidity accepted\n  function approveLiquidity(address _liquidity) external;\n\n  /// @notice Revoke a liquidity pair from being accepted in future\n  /// @param _liquidity The liquidity no longer accepted\n  function revokeLiquidity(address _liquidity) external;\n\n  /// @notice Allows anyone to fund a job with liquidity\n  /// @param _job The address of the job to assign liquidity to\n  /// @param _liquidity The liquidity being added\n  /// @param _amount The amount of liquidity tokens to add\n  function addLiquidityToJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n\n  /// @notice Unbond liquidity for a job\n  /// @dev Can only be called by the job's owner\n  /// @param _job The address of the job being unbound from\n  /// @param _liquidity The liquidity being unbound\n  /// @param _amount The amount of liquidity being removed\n  function unbondLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n\n  /// @notice Withdraw liquidity from a job\n  /// @param _job The address of the job being withdrawn from\n  /// @param _liquidity The liquidity being withdrawn\n  /// @param _receiver The address that will receive the withdrawn liquidity\n  function withdrawLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    address _receiver\n  ) external;\n}\n\n/// @title Keep3rJobManager contract\n/// @notice Handles the addition and withdrawal of credits from a job\ninterface IKeep3rJobManager {\n  // Events\n\n  /// @notice Emitted when Keep3rJobManager#addJob is called\n  /// @param _job The address of the job to add\n  /// @param _jobOwner The job's owner\n  event JobAddition(address indexed _job, address indexed _jobOwner);\n\n  // Errors\n\n  /// @notice Throws when trying to add a job that has already been added\n  error JobAlreadyAdded();\n\n  /// @notice Throws when the address that is trying to register as a keeper is already a keeper\n  error AlreadyAKeeper();\n\n  // Methods\n\n  /// @notice Allows any caller to add a new job\n  /// @param _job Address of the contract for which work should be performed\n  function addJob(address _job) external;\n}\n\n/// @title Keep3rJobWorkable contract\n/// @notice Handles the mechanisms jobs can pay keepers with along with the restrictions jobs can put on keepers before they can work on jobs\ninterface IKeep3rJobWorkable {\n  // Events\n\n  /// @notice Emitted when a keeper is validated before a job\n  /// @param _gasLeft The amount of gas that the transaction has left at the moment of keeper validation\n  event KeeperValidation(uint256 _gasLeft);\n\n  /// @notice Emitted when a keeper works a job\n  /// @param _credit The address of the asset in which the keeper is paid\n  /// @param _job The address of the job the keeper has worked\n  /// @param _keeper The address of the keeper that has worked the job\n  /// @param _amount The amount that has been paid out to the keeper in exchange for working the job\n  /// @param _gasLeft The amount of gas that the transaction has left at the moment of payment\n  event KeeperWork(address indexed _credit, address indexed _job, address indexed _keeper, uint256 _amount, uint256 _gasLeft);\n\n  // Errors\n\n  /// @notice Throws if the address claiming to be a job is not in the list of approved jobs\n  error JobUnapproved();\n\n  /// @notice Throws if the amount of funds in the job is less than the payment that must be paid to the keeper that works that job\n  error InsufficientFunds();\n\n  // Methods\n\n  /// @notice Confirms if the current keeper is registered, can be used for general (non critical) functions\n  /// @param _keeper The keeper being investigated\n  /// @return _isKeeper Whether the address passed as a parameter is a keeper or not\n  function isKeeper(address _keeper) external returns (bool _isKeeper);\n\n  /// @notice Confirms if the current keeper is registered and has a minimum bond of any asset. Should be used for protected functions\n  /// @param _keeper The keeper to check\n  /// @param _bond The bond token being evaluated\n  /// @param _minBond The minimum amount of bonded tokens\n  /// @param _earned The minimum funds earned in the keepers lifetime\n  /// @param _age The minimum keeper age required\n  /// @return _isBondedKeeper Whether the `_keeper` meets the given requirements\n  function isBondedKeeper(\n    address _keeper,\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) external returns (bool _isBondedKeeper);\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Automatically calculates the payment for the keeper\n  /// @param _keeper Address of the keeper that performed the work\n  function worked(address _keeper) external;\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Pays the keeper that performs the work with KP3R\n  /// @param _keeper Address of the keeper that performed the work\n  /// @param _payment The reward that should be allocated for the job\n  function bondedPayment(address _keeper, uint256 _payment) external;\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Pays the keeper that performs the work with a specific token\n  /// @param _token The asset being awarded to the keeper\n  /// @param _keeper Address of the keeper that performed the work\n  /// @param _amount The reward that should be allocated\n  function directTokenPayment(\n    address _token,\n    address _keeper,\n    uint256 _amount\n  ) external;\n}\n\n/// @title Keep3rJobOwnership contract\n/// @notice Handles the ownership of the jobs\ninterface IKeep3rJobOwnership {\n  // Events\n\n  /// @notice Emitted when Keep3rJobOwnership#changeJobOwnership is called\n  /// @param _job The address of the job proposed to have a change of owner\n  /// @param _owner The current owner of the job\n  /// @param _pendingOwner The new address proposed to be the owner of the job\n  event JobOwnershipChange(address indexed _job, address indexed _owner, address indexed _pendingOwner);\n\n  /// @notice Emitted when Keep3rJobOwnership#JobOwnershipAssent is called\n  /// @param _job The address of the job which the proposed owner will now own\n  /// @param _previousOwner The previous owner of the job\n  /// @param _newOwner The newowner of the job\n  event JobOwnershipAssent(address indexed _job, address indexed _previousOwner, address indexed _newOwner);\n\n  // Errors\n\n  /// @notice Throws when the caller of the function is not the job owner\n  error OnlyJobOwner();\n\n  /// @notice Throws when the caller of the function is not the pending job owner\n  error OnlyPendingJobOwner();\n\n  // Variables\n\n  /// @notice Maps the job to the owner of the job (job => user)\n  /// @return _owner The addres of the owner of the job\n  function jobOwner(address _job) external view returns (address _owner);\n\n  /// @notice Maps the owner of the job to its pending owner (job => user)\n  /// @return _pendingOwner The address of the pending owner of the job\n  function jobPendingOwner(address _job) external view returns (address _pendingOwner);\n\n  // Methods\n\n  /// @notice Proposes a new address to be the owner of the job\n  function changeJobOwnership(address _job, address _newOwner) external;\n\n  /// @notice The proposed address accepts to be the owner of the job\n  function acceptJobOwnership(address _job) external;\n}\n\n/// @title Keep3rJobMigration contract\n/// @notice Handles the migration process of jobs to different addresses\ninterface IKeep3rJobMigration {\n  // Events\n\n  /// @notice Emitted when Keep3rJobMigration#migrateJob function is called\n  /// @param _fromJob The address of the job that requests to migrate\n  /// @param _toJob The address at which the job requests to migrate\n  event JobMigrationRequested(address indexed _fromJob, address _toJob);\n\n  /// @notice Emitted when Keep3rJobMigration#acceptJobMigration function is called\n  /// @param _fromJob The address of the job that requested to migrate\n  /// @param _toJob The address at which the job had requested to migrate\n  event JobMigrationSuccessful(address _fromJob, address indexed _toJob);\n\n  // Errors\n\n  /// @notice Throws when the address of the job that requests to migrate wants to migrate to its same address\n  error JobMigrationImpossible();\n\n  /// @notice Throws when the _toJob address differs from the address being tracked in the pendingJobMigrations mapping\n  error JobMigrationUnavailable();\n\n  /// @notice Throws when cooldown between migrations has not yet passed\n  error JobMigrationLocked();\n\n  // Variables\n\n  /// @notice Maps the jobs that have requested a migration to the address they have requested to migrate to\n  /// @return _toJob The address to which the job has requested to migrate to\n  function pendingJobMigrations(address _fromJob) external view returns (address _toJob);\n\n  // Methods\n\n  /// @notice Initializes the migration process for a job by adding the request to the pendingJobMigrations mapping\n  /// @param _fromJob The address of the job that is requesting to migrate\n  /// @param _toJob The address at which the job is requesting to migrate\n  function migrateJob(address _fromJob, address _toJob) external;\n\n  /// @notice Completes the migration process for a job\n  /// @dev Unbond/withdraw process doesn't get migrated\n  /// @param _fromJob The address of the job that requested to migrate\n  /// @param _toJob The address to which the job wants to migrate to\n  function acceptJobMigration(address _fromJob, address _toJob) external;\n}\n\n/// @title Keep3rJobDisputable contract\n/// @notice Handles the actions that can be taken on a disputed job\ninterface IKeep3rJobDisputable is IKeep3rJobFundableCredits, IKeep3rJobFundableLiquidity {\n  // Events\n\n  /// @notice Emitted when Keep3rJobDisputable#slashTokenFromJob is called\n  /// @param _job The address of the job from which the token will be slashed\n  /// @param _token The address of the token being slashed\n  /// @param _slasher The user that slashes the token\n  /// @param _amount The amount of the token being slashed\n  event JobSlashToken(address indexed _job, address _token, address indexed _slasher, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobDisputable#slashLiquidityFromJob is called\n  /// @param _job The address of the job from which the liquidity will be slashed\n  /// @param _liquidity The address of the liquidity being slashed\n  /// @param _slasher The user that slashes the liquidity\n  /// @param _amount The amount of the liquidity being slashed\n  event JobSlashLiquidity(address indexed _job, address _liquidity, address indexed _slasher, uint256 _amount);\n\n  // Errors\n\n  /// @notice Throws when the token trying to be slashed doesn't exist\n  error JobTokenUnexistent();\n\n  /// @notice Throws when someone tries to slash more tokens than the job has\n  error JobTokenInsufficient();\n\n  // Methods\n\n  /// @notice Allows governance or slasher to slash a job specific token\n  /// @param _job The address of the job from which the token will be slashed\n  /// @param _token The address of the token that will be slashed\n  /// @param _amount The amount of the token that will be slashed\n  function slashTokenFromJob(\n    address _job,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  /// @notice Allows governance or a slasher to slash liquidity from a job\n  /// @param _job The address being slashed\n  /// @param _liquidity The address of the liquidity that will be slashed\n  /// @param _amount The amount of liquidity that will be slashed\n  function slashLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n}\n\n// solhint-disable-next-line no-empty-blocks\ninterface IKeep3rJobs is IKeep3rJobOwnership, IKeep3rJobDisputable, IKeep3rJobMigration, IKeep3rJobManager, IKeep3rJobWorkable {\n\n}\n"
    },
    "keep3r-v2/solidity/interfaces/peripherals/IKeep3rKeepers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\n/// @title Keep3rKeeperFundable contract\n/// @notice Handles the actions required to become a keeper\ninterface IKeep3rKeeperFundable {\n  // Events\n\n  /// @notice Emitted when Keep3rKeeperFundable#activate is called\n  /// @param _keeper The keeper that has been activated\n  /// @param _bond The asset the keeper has bonded\n  /// @param _amount The amount of the asset the keeper has bonded\n  event Activation(address indexed _keeper, address indexed _bond, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperFundable#withdraw is called\n  /// @param _keeper The caller of Keep3rKeeperFundable#withdraw function\n  /// @param _bond The asset to withdraw from the bonding pool\n  /// @param _amount The amount of funds withdrawn\n  event Withdrawal(address indexed _keeper, address indexed _bond, uint256 _amount);\n\n  // Errors\n\n  /// @notice Throws when the address that is trying to register as a job is already a job\n  error AlreadyAJob();\n\n  // Methods\n\n  /// @notice Beginning of the bonding process\n  /// @param _bonding The asset being bound\n  /// @param _amount The amount of bonding asset being bound\n  function bond(address _bonding, uint256 _amount) external;\n\n  /// @notice Beginning of the unbonding process\n  /// @param _bonding The asset being unbound\n  /// @param _amount Allows for partial unbonding\n  function unbond(address _bonding, uint256 _amount) external;\n\n  /// @notice End of the bonding process after bonding time has passed\n  /// @param _bonding The asset being activated as bond collateral\n  function activate(address _bonding) external;\n\n  /// @notice Withdraw funds after unbonding has finished\n  /// @param _bonding The asset to withdraw from the bonding pool\n  function withdraw(address _bonding) external;\n}\n\n/// @title Keep3rKeeperDisputable contract\n/// @notice Handles the actions that can be taken on a disputed keeper\ninterface IKeep3rKeeperDisputable {\n  // Events\n\n  /// @notice Emitted when Keep3rKeeperDisputable#slash is called\n  /// @param _keeper The slashed keeper\n  /// @param _slasher The user that called Keep3rKeeperDisputable#slash\n  /// @param _amount The amount of credits slashed from the keeper\n  event KeeperSlash(address indexed _keeper, address indexed _slasher, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperDisputable#revoke is called\n  /// @param _keeper The revoked keeper\n  /// @param _slasher The user that called Keep3rKeeperDisputable#revoke\n  event KeeperRevoke(address indexed _keeper, address indexed _slasher);\n\n  /// @notice Keeper revoked\n\n  // Methods\n\n  /// @notice Allows governance to slash a keeper based on a dispute\n  /// @param _keeper The address being slashed\n  /// @param _bonded The asset being slashed\n  /// @param _amount The amount being slashed\n  function slash(\n    address _keeper,\n    address _bonded,\n    uint256 _amount\n  ) external;\n\n  /// @notice Blacklists a keeper from participating in the network\n  /// @param _keeper The address being slashed\n  function revoke(address _keeper) external;\n}\n\n// solhint-disable-next-line no-empty-blocks\n\n/// @title Keep3rKeepers contract\ninterface IKeep3rKeepers is IKeep3rKeeperDisputable {\n\n}\n"
    },
    "keep3r-v2/solidity/interfaces/peripherals/IKeep3rAccountance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\n/// @title Keep3rDisputable contract\n/// @notice Disputes keepers, or if they're already disputed, it can resolve the case\n/// @dev Argument `bonding` can be the address of either a token or a liquidity\ninterface IKeep3rAccountance {\n  // Events\n\n  /// @notice Emitted when the bonding process of a new keeper begins\n  /// @param _keeper The caller of Keep3rKeeperFundable#bond function\n  /// @param _bonding The asset the keeper has bonded\n  /// @param _amount The amount the keeper has bonded\n  event Bonding(address indexed _keeper, address indexed _bonding, uint256 _amount);\n\n  /// @notice Emitted when a keeper or job begins the unbonding process to withdraw the funds\n  /// @param _keeperOrJob The keeper or job that began the unbonding process\n  /// @param _unbonding The liquidity pair or asset being unbonded\n  /// @param _amount The amount being unbonded\n  event Unbonding(address indexed _keeperOrJob, address indexed _unbonding, uint256 _amount);\n\n  // Variables\n\n  /// @notice Tracks the total KP3R earnings of a keeper since it started working\n  /// @return _workCompleted Total KP3R earnings of a keeper since it started working\n  function workCompleted(address _keeper) external view returns (uint256 _workCompleted);\n\n  /// @notice Tracks when a keeper was first registered\n  /// @return timestamp The time at which the keeper was first registered\n  function firstSeen(address _keeper) external view returns (uint256 timestamp);\n\n  /// @notice Tracks if a keeper or job has a pending dispute\n  /// @return _disputed Whether a keeper or job has a pending dispute\n  function disputes(address _keeperOrJob) external view returns (bool _disputed);\n\n  /// @notice Tracks how much a keeper has bonded of a certain token\n  /// @return _bonds Amount of a certain token that a keeper has bonded\n  function bonds(address _keeper, address _bond) external view returns (uint256 _bonds);\n\n  /// @notice The current token credits available for a job\n  /// @return _amount The amount of token credits available for a job\n  function jobTokenCredits(address _job, address _token) external view returns (uint256 _amount);\n\n  /// @notice Tracks the amount of assets deposited in pending bonds\n  /// @return _pendingBonds Amount of a certain asset a keeper has unbonding\n  function pendingBonds(address _keeper, address _bonding) external view returns (uint256 _pendingBonds);\n\n  /// @notice Tracks when a bonding for a keeper can be activated\n  /// @return _timestamp Time at which the bonding for a keeper can be activated\n  function canActivateAfter(address _keeper, address _bonding) external view returns (uint256 _timestamp);\n\n  /// @notice Tracks when keeper bonds are ready to be withdrawn\n  /// @return _timestamp Time at which the keeper bonds are ready to be withdrawn\n  function canWithdrawAfter(address _keeper, address _bonding) external view returns (uint256 _timestamp);\n\n  /// @notice Tracks how much keeper bonds are to be withdrawn\n  /// @return _pendingUnbonds The amount of keeper bonds that are to be withdrawn\n  function pendingUnbonds(address _keeper, address _bonding) external view returns (uint256 _pendingUnbonds);\n\n  /// @notice Checks whether the address has ever bonded an asset\n  /// @return _hasBonded Whether the address has ever bonded an asset\n  function hasBonded(address _keeper) external view returns (bool _hasBonded);\n\n  // Methods\n  /// @notice Lists all jobs\n  /// @return _jobList Array with all the jobs in _jobs\n  function jobs() external view returns (address[] memory _jobList);\n\n  /// @notice Lists all keepers\n  /// @return _keeperList Array with all the jobs in keepers\n  function keepers() external view returns (address[] memory _keeperList);\n\n  // Errors\n\n  /// @notice Throws when an address is passed as a job, but that address is not a job\n  error JobUnavailable();\n\n  /// @notice Throws when an action that requires an undisputed job is applied on a disputed job\n  error JobDisputed();\n}\n"
    },
    "keep3r-v2/solidity/interfaces/peripherals/IKeep3rRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\n/// @title Keep3rRoles contract\n/// @notice Manages the Keep3r specific roles\ninterface IKeep3rRoles {\n  // Events\n\n  /// @notice Emitted when a slasher is added\n  /// @param _slasher Address of the added slasher\n  event SlasherAdded(address _slasher);\n\n  /// @notice Emitted when a slasher is removed\n  /// @param _slasher Address of the removed slasher\n  event SlasherRemoved(address _slasher);\n\n  /// @notice Emitted when a disputer is added\n  /// @param _disputer Address of the added disputer\n  event DisputerAdded(address _disputer);\n\n  /// @notice Emitted when a disputer is removed\n  /// @param _disputer Address of the removed disputer\n  event DisputerRemoved(address _disputer);\n\n  // Variables\n\n  /// @notice Maps an address to a boolean to determine whether the address is a slasher or not.\n  /// @return _isSlasher Whether the address is a slasher or not\n  function slashers(address _slasher) external view returns (bool _isSlasher);\n\n  /// @notice Maps an address to a boolean to determine whether the address is a disputer or not.\n  /// @return _isDisputer Whether the address is a disputer or not\n  function disputers(address _disputer) external view returns (bool _isDisputer);\n\n  // Errors\n\n  /// @notice Throws if the address is already a registered slasher\n  error SlasherExistent();\n\n  /// @notice Throws if caller is not a registered slasher\n  error SlasherUnexistent();\n\n  /// @notice Throws if the address is already a registered disputer\n  error DisputerExistent();\n\n  /// @notice Throws if caller is not a registered disputer\n  error DisputerUnexistent();\n\n  /// @notice Throws if the msg.sender is not a slasher or is not a part of governance\n  error OnlySlasher();\n\n  /// @notice Throws if the msg.sender is not a disputer or is not a part of governance\n  error OnlyDisputer();\n\n  // Methods\n\n  /// @notice Registers a slasher by updating the slashers mapping\n  function addSlasher(address _slasher) external;\n\n  /// @notice Removes a slasher by updating the slashers mapping\n  function removeSlasher(address _slasher) external;\n\n  /// @notice Registers a disputer by updating the disputers mapping\n  function addDisputer(address _disputer) external;\n\n  /// @notice Removes a disputer by updating the disputers mapping\n  function removeDisputer(address _disputer) external;\n}\n"
    },
    "keep3r-v2/solidity/interfaces/peripherals/IKeep3rParameters.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IBaseErrors.sol';\n\n/// @title Keep3rParameters contract\n/// @notice Handles and sets all the required parameters for Keep3r\n\ninterface IKeep3rParameters is IBaseErrors {\n  // Events\n\n  /// @notice Emitted when the Keep3rHelper address is changed\n  /// @param _keep3rHelper The address of Keep3rHelper's contract\n  event Keep3rHelperChange(address _keep3rHelper);\n\n  /// @notice Emitted when the Keep3rV1 address is changed\n  /// @param _keep3rV1 The address of Keep3rV1's contract\n  event Keep3rV1Change(address _keep3rV1);\n\n  /// @notice Emitted when the Keep3rV1Proxy address is changed\n  /// @param _keep3rV1Proxy The address of Keep3rV1Proxy's contract\n  event Keep3rV1ProxyChange(address _keep3rV1Proxy);\n\n  /// @notice Emitted when the KP3R-WETH pool address is changed\n  /// @param _kp3rWethPool The address of the KP3R-WETH pool\n  event Kp3rWethPoolChange(address _kp3rWethPool);\n\n  /// @notice Emitted when bondTime is changed\n  /// @param _bondTime The new bondTime\n  event BondTimeChange(uint256 _bondTime);\n\n  /// @notice Emitted when _liquidityMinimum is changed\n  /// @param _liquidityMinimum The new _liquidityMinimum\n  event LiquidityMinimumChange(uint256 _liquidityMinimum);\n\n  /// @notice Emitted when _unbondTime is changed\n  /// @param _unbondTime The new _unbondTime\n  event UnbondTimeChange(uint256 _unbondTime);\n\n  /// @notice Emitted when _rewardPeriodTime is changed\n  /// @param _rewardPeriodTime The new _rewardPeriodTime\n  event RewardPeriodTimeChange(uint256 _rewardPeriodTime);\n\n  /// @notice Emitted when the inflationPeriod is changed\n  /// @param _inflationPeriod The new inflationPeriod\n  event InflationPeriodChange(uint256 _inflationPeriod);\n\n  /// @notice Emitted when the fee is changed\n  /// @param _fee The new token credits fee\n  event FeeChange(uint256 _fee);\n\n  // Variables\n\n  /// @notice Address of Keep3rHelper's contract\n  /// @return _keep3rHelper The address of Keep3rHelper's contract\n  function keep3rHelper() external view returns (address _keep3rHelper);\n\n  /// @notice Address of Keep3rV1's contract\n  /// @return _keep3rV1 The address of Keep3rV1's contract\n  function keep3rV1() external view returns (address _keep3rV1);\n\n  /// @notice Address of Keep3rV1Proxy's contract\n  /// @return _keep3rV1Proxy The address of Keep3rV1Proxy's contract\n  function keep3rV1Proxy() external view returns (address _keep3rV1Proxy);\n\n  /// @notice Address of the KP3R-WETH pool\n  /// @return _kp3rWethPool The address of KP3R-WETH pool\n  function kp3rWethPool() external view returns (address _kp3rWethPool);\n\n  /// @notice The amount of time required to pass after a keeper has bonded assets for it to be able to activate\n  /// @return _days The required bondTime in days\n  function bondTime() external view returns (uint256 _days);\n\n  /// @notice The amount of time required to pass before a keeper can unbond what he has bonded\n  /// @return _days The required unbondTime in days\n  function unbondTime() external view returns (uint256 _days);\n\n  /// @notice The minimum amount of liquidity required to fund a job per liquidity\n  /// @return _amount The minimum amount of liquidity in KP3R\n  function liquidityMinimum() external view returns (uint256 _amount);\n\n  /// @notice The amount of time between each scheduled credits reward given to a job\n  /// @return _days The reward period in days\n  function rewardPeriodTime() external view returns (uint256 _days);\n\n  /// @notice The inflation period is the denominator used to regulate the emission of KP3R\n  /// @return _period The denominator used to regulate the emission of KP3R\n  function inflationPeriod() external view returns (uint256 _period);\n\n  /// @notice The fee to be sent to governance when a user adds liquidity to a job\n  /// @return _amount The fee amount to be sent to governance when a user adds liquidity to a job\n  function fee() external view returns (uint256 _amount);\n\n  // solhint-disable func-name-mixedcase\n  /// @notice The base that will be used to calculate the fee\n  /// @return _base The base that will be used to calculate the fee\n  function BASE() external view returns (uint256 _base);\n\n  /// @notice The minimum rewardPeriodTime value to be set\n  /// @return _minPeriod The minimum reward period in seconds\n  function MIN_REWARD_PERIOD_TIME() external view returns (uint256 _minPeriod);\n\n  // solhint-enable func-name-mixedcase\n\n  // Errors\n\n  /// @notice Throws if the reward period is less than the minimum reward period time\n  error MinRewardPeriod();\n\n  /// @notice Throws if either a job or a keeper is disputed\n  error Disputed();\n\n  /// @notice Throws if there are no bonded assets\n  error BondsUnexistent();\n\n  /// @notice Throws if the time required to bond an asset has not passed yet\n  error BondsLocked();\n\n  /// @notice Throws if there are no bonds to withdraw\n  error UnbondsUnexistent();\n\n  /// @notice Throws if the time required to withdraw the bonds has not passed yet\n  error UnbondsLocked();\n\n  // Methods\n\n  /// @notice Sets the Keep3rHelper address\n  /// @param _keep3rHelper The Keep3rHelper address\n  function setKeep3rHelper(address _keep3rHelper) external;\n\n  /// @notice Sets the Keep3rV1 address\n  /// @param _keep3rV1 The Keep3rV1 address\n  function setKeep3rV1(address _keep3rV1) external;\n\n  /// @notice Sets the Keep3rV1Proxy address\n  /// @param _keep3rV1Proxy The Keep3rV1Proxy address\n  function setKeep3rV1Proxy(address _keep3rV1Proxy) external;\n\n  /// @notice Sets the KP3R-WETH pool address\n  /// @param _kp3rWethPool The KP3R-WETH pool address\n  function setKp3rWethPool(address _kp3rWethPool) external;\n\n  /// @notice Sets the bond time required to activate as a keeper\n  /// @param _bond The new bond time\n  function setBondTime(uint256 _bond) external;\n\n  /// @notice Sets the unbond time required unbond what has been bonded\n  /// @param _unbond The new unbond time\n  function setUnbondTime(uint256 _unbond) external;\n\n  /// @notice Sets the minimum amount of liquidity required to fund a job\n  /// @param _liquidityMinimum The new minimum amount of liquidity\n  function setLiquidityMinimum(uint256 _liquidityMinimum) external;\n\n  /// @notice Sets the time required to pass between rewards for jobs\n  /// @param _rewardPeriodTime The new amount of time required to pass between rewards\n  function setRewardPeriodTime(uint256 _rewardPeriodTime) external;\n\n  /// @notice Sets the new inflation period\n  /// @param _inflationPeriod The new inflation period\n  function setInflationPeriod(uint256 _inflationPeriod) external;\n\n  /// @notice Sets the new fee\n  /// @param _fee The new fee\n  function setFee(uint256 _fee) external;\n}\n"
    },
    "keep3r-v2/solidity/interfaces/peripherals/IBaseErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IBaseErrors {\n  /// @notice Throws if a variable is assigned to the zero address\n  error ZeroAddress();\n}\n"
    },
    "contracts/interfaces/IDCAHubCompanion.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAPermissionManager.sol';\nimport './ILegacyDCAHub.sol';\nimport './ISharedTypes.sol';\n\n/**\n * @notice This contract exposes many utils that are also available through libraries. The idea is to make\n *         these functions available here, so others don't need to deploy new contracts\n */\ninterface IDCAHubCompanionLibrariesHandler {\n  /**\n   * @notice Takes a list of pairs and returns how it would look like to execute a swap for all of them\n   * @dev Please note that this function is very expensive. Ideally, it would be used for off-chain purposes\n   * @param hub The address of the DCAHub\n   * @param pairs The pairs to be involved in the swap\n   * @param calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\n   *        the possibility to calculate the next swap information for privileged and non-privileged accounts\n   * @param oracleData Bytes to send to the oracle when executing a quote\n   * @return How executing a swap for all the given pairs would look like\n   */\n  function getNextSwapInfo(\n    IDCAHub hub,\n    Pair[] calldata pairs,\n    bool calculatePrivilegedAvailability,\n    bytes calldata oracleData\n  ) external view returns (IDCAHub.SwapInfo memory);\n\n  /**\n   * @notice Takes a list of pairs and returns how it would look like to execute a swap for all of them\n   * @dev Please note that this function is very expensive. Ideally, it would be used for off-chain purposes\n   * @param hub The address of the DCAHub\n   * @param pairs The pairs to be involved in the swap\n   * @return How executing a swap for all the given pairs would look like\n   */\n  function legacyGetNextSwapInfo(ILegacyDCAHub hub, Pair[] calldata pairs) external view returns (ILegacyDCAHub.SwapInfo memory);\n\n  /**\n   * @notice Returns how many seconds left until the next swap is available for a list of pairs\n   * @dev Tokens in pairs may be passed in either tokenA/tokenB or tokenB/tokenA order\n   * @param hub The address of the DCAHub\n   * @param pairs Pairs to check\n   * @param calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\n   *        the possibility to calculate the seconds until next swap for privileged and non-privileged accounts\n   * @return The amount of seconds until next swap for each of the pairs\n   */\n  function secondsUntilNextSwap(\n    IDCAHub hub,\n    Pair[] calldata pairs,\n    bool calculatePrivilegedAvailability\n  ) external view returns (uint256[] memory);\n}\n\ninterface IDCAHubCompanionHubProxyHandler {\n  /// @notice Thrown when a user tries operate on a position that they don't have access to\n  error UnauthorizedCaller();\n\n  /**\n   * @notice Creates a new position\n   * @dev Meant to be used as part of a multicall\n   * @param hub The address of the DCAHub\n   * @param from The address of the \"from\" token\n   * @param to The address of the \"to\" token\n   * @param amount How many \"from\" tokens will be swapped in total\n   * @param amountOfSwaps How many swaps to execute for this position\n   * @param swapInterval How frequently the position's swaps should be executed\n   * @param owner The address of the owner of the position being created\n   * @param miscellaneous Bytes that will be emitted, and associated with the position. If empty, no event will be emitted\n   * @return positionId The id of the created position\n   */\n  function deposit(\n    IDCAHub hub,\n    address from,\n    address to,\n    uint256 amount,\n    uint32 amountOfSwaps,\n    uint32 swapInterval,\n    address owner,\n    IDCAPermissionManager.PermissionSet[] calldata permissions,\n    bytes calldata miscellaneous\n  ) external payable returns (uint256 positionId);\n\n  /**\n   * @notice Creates a new position using the entire balance available on the contract\n   * @dev Meant to be used as part of a multicall\n   * @param hub The address of the DCAHub\n   * @param from The address of the \"from\" token\n   * @param to The address of the \"to\" token\n   * @param amountOfSwaps How many swaps to execute for this position\n   * @param swapInterval How frequently the position's swaps should be executed\n   * @param owner The address of the owner of the position being created\n   * @param miscellaneous Bytes that will be emitted, and associated with the position. If empty, no event will be emitted\n   * @return positionId The id of the created position\n   */\n  function depositWithBalanceOnContract(\n    IDCAHub hub,\n    address from,\n    address to,\n    uint32 amountOfSwaps,\n    uint32 swapInterval,\n    address owner,\n    IDCAPermissionManager.PermissionSet[] calldata permissions,\n    bytes calldata miscellaneous\n  ) external payable returns (uint256 positionId);\n\n  /**\n   * @notice Call the hub and withdraws all swapped tokens from a position to a recipient\n   * @dev Meant to be used as part of a multicall\n   * @param hub The address of the DCAHub\n   * @param positionId The position's id\n   * @param recipient The address to withdraw swapped tokens to\n   * @return swapped How much was withdrawn\n   */\n  function withdrawSwapped(\n    IDCAHub hub,\n    uint256 positionId,\n    address recipient\n  ) external payable returns (uint256 swapped);\n\n  /**\n   * @notice Call the hub and withdraws all swapped tokens from multiple positions\n   * @dev Meant to be used as part of a multicall\n   * @param hub The address of the DCAHub\n   * @param positions A list positions, grouped by `to` token\n   * @param recipient The address to withdraw swapped tokens to\n   * @return withdrawn How much was withdrawn for each token\n   */\n  function withdrawSwappedMany(\n    IDCAHub hub,\n    IDCAHub.PositionSet[] calldata positions,\n    address recipient\n  ) external payable returns (uint256[] memory withdrawn);\n\n  /**\n   * @notice Call the hub and takes the unswapped balance, adds the new deposited funds and modifies the position so that\n   * it is executed in `newSwaps` swaps\n   * @dev Meant to be used as part of a multicall\n   * @param hub The address of the DCAHub\n   * @param positionId The position's id\n   * @param amount Amount of funds to add to the position\n   * @param newSwaps The new amount of swaps\n   */\n  function increasePosition(\n    IDCAHub hub,\n    uint256 positionId,\n    uint256 amount,\n    uint32 newSwaps\n  ) external payable;\n\n  /**\n   * @notice Call the hub and takes the unswapped balance, adds the Companion's current balance and modifies the position so that\n   * it is executed in `newSwaps` swaps\n   * @dev Meant to be used as part of a multicall\n   * @param hub The address of the DCAHub\n   * @param positionId The position's id\n   * @param newSwaps The new amount of swaps\n   */\n  function increasePositionWithBalanceOnContract(\n    IDCAHub hub,\n    uint256 positionId,\n    uint32 newSwaps\n  ) external payable;\n\n  /**\n   * @notice Call the hub and withdraws the specified amount from the unswapped balance and modifies the position so that\n   * it is executed in newSwaps swaps\n   * @dev Meant to be used as part of a multicall\n   * @param hub The address of the DCAHub\n   * @param positionId The position's id\n   * @param amount Amount of funds to withdraw from the position\n   * @param newSwaps The new amount of swaps\n   * @param recipient The address to send tokens to\n   */\n  function reducePosition(\n    IDCAHub hub,\n    uint256 positionId,\n    uint256 amount,\n    uint32 newSwaps,\n    address recipient\n  ) external payable;\n\n  /**\n   * @notice Calls the hub and terminates the position and sends all unswapped and swapped balance to the specified recipients\n   * @dev Meant to be used as part of a multicall\n   * @param hub The address of the DCAHub\n   * @param positionId The position's id\n   * @param recipientUnswapped The address to withdraw unswapped tokens to\n   * @param recipientSwapped The address to withdraw swapped tokens to\n   * @return unswapped The unswapped balance sent to `recipientUnswapped`\n   * @return swapped The swapped balance sent to `recipientSwapped`\n   */\n  function terminate(\n    IDCAHub hub,\n    uint256 positionId,\n    address recipientUnswapped,\n    address recipientSwapped\n  ) external payable returns (uint256 unswapped, uint256 swapped);\n\n  /**\n   * @notice Calls the permission manager and sets multiple permissions via signature\n   * @param permissionManager The address of the permission manager\n   * @param permissions The permissions to set\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n   */\n  function multiPermissionPermit(\n    IDCAPermissionManager permissionManager,\n    IDCAPermissionManager.PositionPermissions[] calldata permissions,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external payable;\n\n  /**\n   * @notice Calls the permission manager and sets permissions via signature\n   * @param permissionManager The address of the permission manager\n   * @param permissions The permissions to set\n   * @param tokenId The token's id\n   * @param deadline The deadline timestamp by which the call must be mined for the approve to work\n   * @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n   * @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n   * @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n   */\n  function permissionPermit(\n    IDCAPermissionManager permissionManager,\n    IDCAPermissionManager.PermissionSet[] calldata permissions,\n    uint256 tokenId,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external payable;\n}\n\ninterface IDCAHubCompanion is IDCAHubCompanionLibrariesHandler, IDCAHubCompanionHubProxyHandler {}\n"
    },
    "contracts/interfaces/ILegacyDCAHub.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\n\ninterface ILegacyDCAHub {\n  /// @notice Information about a swap\n  struct SwapInfo {\n    // The tokens involved in the swap\n    TokenInSwap[] tokens;\n    // The pairs involved in the swap\n    PairInSwap[] pairs;\n  }\n\n  /// @notice Information about a token's role in a swap\n  struct TokenInSwap {\n    // The token's address\n    address token;\n    // How much will be given of this token as a reward\n    uint256 reward;\n    // How much of this token needs to be provided by swapper\n    uint256 toProvide;\n    // How much of this token will be paid to the platform\n    uint256 platformFee;\n  }\n\n  /// @notice Information about a pair in a swap\n  struct PairInSwap {\n    // The address of one of the tokens\n    address tokenA;\n    // The address of the other token\n    address tokenB;\n    // How much is 1 unit of token A when converted to B\n    uint256 ratioAToB;\n    // How much is 1 unit of token B when converted to A\n    uint256 ratioBToA;\n    // The swap intervals involved in the swap, represented as a byte\n    bytes1 intervalsInSwap;\n  }\n\n  /**\n   * @notice Returns all information related to the next swap\n   * @dev Will revert with:\n   *      - With InvalidTokens if tokens are not sorted, or if there are duplicates\n   *      - With InvalidPairs if pairs are not sorted (first by indexTokenA and then indexTokenB), or if indexTokenA >= indexTokenB for any pair\n   * @param tokens The tokens involved in the next swap\n   * @param pairs The pairs that you want to swap. Each element of the list points to the index of the token in the tokens array\n   * @return swapInformation The information about the next swap\n   */\n  function getNextSwapInfo(address[] calldata tokens, IDCAHub.PairIndexes[] calldata pairs)\n    external\n    view\n    returns (SwapInfo memory swapInformation);\n\n  /**\n   * @notice Executes a flash swap\n   * @dev Will revert with:\n   *      - With InvalidTokens if tokens are not sorted, or if there are duplicates\n   *      - With InvalidPairs if pairs are not sorted (first by indexTokenA and then indexTokenB), or if indexTokenA >= indexTokenB for any pair\n   *      - With Paused if swaps are paused by protocol\n   *      - With NoSwapsToExecute if there are no swaps to execute for the given pairs\n   *      - With LiquidityNotReturned if the required tokens were not back during the callback\n   * @param tokens The tokens involved in the next swap\n   * @param pairsToSwap The pairs that you want to swap. Each element of the list points to the index of the token in the tokens array\n   * @param rewardRecipient The address to send the reward to\n   * @param callbackHandler Address to call for callback (and send the borrowed tokens to)\n   * @param borrow How much to borrow of each of the tokens in tokens. The amount must match the position of the token in the tokens array\n   * @param callbackData Bytes to send to the caller during the callback\n   * @return Information about the executed swap\n   */\n  function swap(\n    address[] calldata tokens,\n    IDCAHub.PairIndexes[] calldata pairsToSwap,\n    address rewardRecipient,\n    address callbackHandler,\n    uint256[] calldata borrow,\n    bytes calldata callbackData\n  ) external returns (SwapInfo memory);\n}\n"
    },
    "contracts/interfaces/ISharedTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\n/// @notice A pair of tokens\nstruct Pair {\n  address tokenA;\n  address tokenB;\n}\n"
    },
    "contracts/DCAHubCompanion/DCAHubCompanionHubProxyHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../interfaces/IDCAHubCompanion.sol';\n\n/// @dev All public functions are payable, so that they can be multicalled together with other payable functions when msg.value > 0\nabstract contract DCAHubCompanionHubProxyHandler is IDCAHubCompanionHubProxyHandler {\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\n  function permissionPermit(\n    IDCAPermissionManager _permissionManager,\n    IDCAPermissionManager.PermissionSet[] calldata _permissions,\n    uint256 _tokenId,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external payable {\n    _permissionManager.permissionPermit(_permissions, _tokenId, _deadline, _v, _r, _s);\n  }\n\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\n  function multiPermissionPermit(\n    IDCAPermissionManager _permissionManager,\n    IDCAPermissionManager.PositionPermissions[] calldata _permissions,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external payable {\n    _permissionManager.multiPermissionPermit(_permissions, _deadline, _v, _r, _s);\n  }\n\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\n  function deposit(\n    IDCAHub _hub,\n    address _from,\n    address _to,\n    uint256 _amount,\n    uint32 _amountOfSwaps,\n    uint32 _swapInterval,\n    address _owner,\n    IDCAPermissionManager.PermissionSet[] calldata _permissions,\n    bytes calldata _miscellaneous\n  ) public payable virtual returns (uint256 _positionId) {\n    _approveHub(address(_from), _hub, _amount);\n    _positionId = _miscellaneous.length > 0\n      ? _hub.deposit(_from, _to, _amount, _amountOfSwaps, _swapInterval, _owner, _permissions, _miscellaneous)\n      : _hub.deposit(_from, _to, _amount, _amountOfSwaps, _swapInterval, _owner, _permissions);\n  }\n\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\n  function depositWithBalanceOnContract(\n    IDCAHub _hub,\n    address _from,\n    address _to,\n    uint32 _amountOfSwaps,\n    uint32 _swapInterval,\n    address _owner,\n    IDCAPermissionManager.PermissionSet[] calldata _permissions,\n    bytes calldata _miscellaneous\n  ) external payable returns (uint256 _positionId) {\n    uint256 _amount = IERC20(_from).balanceOf(address(this));\n    return deposit(_hub, _from, _to, _amount, _amountOfSwaps, _swapInterval, _owner, _permissions, _miscellaneous);\n  }\n\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\n  function withdrawSwapped(\n    IDCAHub _hub,\n    uint256 _positionId,\n    address _recipient\n  ) external payable verifyPermission(_hub, _positionId, IDCAPermissionManager.Permission.WITHDRAW) returns (uint256 _swapped) {\n    _swapped = _hub.withdrawSwapped(_positionId, _recipient);\n  }\n\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\n  function withdrawSwappedMany(\n    IDCAHub _hub,\n    IDCAHub.PositionSet[] calldata _positions,\n    address _recipient\n  ) external payable returns (uint256[] memory _withdrawn) {\n    for (uint256 i = 0; i < _positions.length; ) {\n      uint256[] memory _positionIds = _positions[i].positionIds;\n      for (uint256 j = 0; j < _positionIds.length; ) {\n        _checkPermissionOrFail(_hub, _positionIds[j], IDCAPermissionManager.Permission.WITHDRAW);\n        unchecked {\n          j++;\n        }\n      }\n      unchecked {\n        i++;\n      }\n    }\n    _withdrawn = _hub.withdrawSwappedMany(_positions, _recipient);\n  }\n\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\n  function increasePosition(\n    IDCAHub _hub,\n    uint256 _positionId,\n    uint256 _amount,\n    uint32 _newSwaps\n  ) external payable verifyPermission(_hub, _positionId, IDCAPermissionManager.Permission.INCREASE) {\n    IERC20Metadata _from = _hub.userPosition(_positionId).from;\n    _approveHub(address(_from), _hub, _amount);\n    _hub.increasePosition(_positionId, _amount, _newSwaps);\n  }\n\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\n  function increasePositionWithBalanceOnContract(\n    IDCAHub _hub,\n    uint256 _positionId,\n    uint32 _newSwaps\n  ) external payable verifyPermission(_hub, _positionId, IDCAPermissionManager.Permission.INCREASE) {\n    IERC20Metadata _from = _hub.userPosition(_positionId).from;\n    uint256 _amount = _from.balanceOf(address(this));\n    _approveHub(address(_from), _hub, _amount);\n    _hub.increasePosition(_positionId, _amount, _newSwaps);\n  }\n\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\n  function reducePosition(\n    IDCAHub _hub,\n    uint256 _positionId,\n    uint256 _amount,\n    uint32 _newSwaps,\n    address _recipient\n  ) external payable verifyPermission(_hub, _positionId, IDCAPermissionManager.Permission.REDUCE) {\n    _hub.reducePosition(_positionId, _amount, _newSwaps, _recipient);\n  }\n\n  /// @inheritdoc IDCAHubCompanionHubProxyHandler\n  function terminate(\n    IDCAHub _hub,\n    uint256 _positionId,\n    address _recipientUnswapped,\n    address _recipientSwapped\n  )\n    external\n    payable\n    verifyPermission(_hub, _positionId, IDCAPermissionManager.Permission.TERMINATE)\n    returns (uint256 _unswapped, uint256 _swapped)\n  {\n    (_unswapped, _swapped) = _hub.terminate(_positionId, _recipientUnswapped, _recipientSwapped);\n  }\n\n  function _approveHub(\n    address _token,\n    IDCAHub _hub,\n    uint256 _amount\n  ) internal {\n    uint256 _allowance = IERC20(_token).allowance(address(this), address(_hub));\n    if (_allowance < _amount) {\n      if (_allowance > 0) {\n        IERC20(_token).approve(address(_hub), 0); // We do this because some tokens (like USDT) fail if we don't\n      }\n      IERC20(_token).approve(address(_hub), type(uint256).max);\n    }\n  }\n\n  function _checkPermissionOrFail(\n    IDCAHub _hub,\n    uint256 _positionId,\n    IDCAPermissionManager.Permission _permission\n  ) internal view {\n    if (!_hub.permissionManager().hasPermission(_positionId, msg.sender, _permission)) revert UnauthorizedCaller();\n  }\n\n  modifier verifyPermission(\n    IDCAHub _hub,\n    uint256 _positionId,\n    IDCAPermissionManager.Permission _permission\n  ) {\n    _checkPermissionOrFail(_hub, _positionId, _permission);\n    _;\n  }\n}\n"
    },
    "contracts/mocks/DCAHubCompanion/DCAHubCompanionHubProxyHandler.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../../DCAHubCompanion/DCAHubCompanionHubProxyHandler.sol';\n\ncontract DCAHubCompanionHubProxyHandlerMock is DCAHubCompanionHubProxyHandler {\n  struct DepositCall {\n    IDCAHub hub;\n    address from;\n    address to;\n    uint256 amount;\n    uint32 amountOfSwaps;\n    uint32 swapInterval;\n    address owner;\n    IDCAPermissionManager.PermissionSet[] permissions;\n    bytes miscellaneous;\n  }\n\n  DepositCall[] private _depositCalls;\n\n  function depositCalls() external view returns (DepositCall[] memory) {\n    return _depositCalls;\n  }\n\n  function deposit(\n    IDCAHub _hub,\n    address _from,\n    address _to,\n    uint256 _amount,\n    uint32 _amountOfSwaps,\n    uint32 _swapInterval,\n    address _owner,\n    IDCAPermissionManager.PermissionSet[] calldata _permissions,\n    bytes calldata _miscellaneous\n  ) public payable override returns (uint256 _positionId) {\n    _depositCalls.push();\n    DepositCall storage _ref = _depositCalls[_depositCalls.length - 1];\n    _ref.hub = _hub;\n    _ref.from = _from;\n    _ref.to = _to;\n    _ref.amount = _amount;\n    _ref.amountOfSwaps = _amountOfSwaps;\n    _ref.swapInterval = _swapInterval;\n    _ref.owner = _owner;\n    _ref.miscellaneous = _miscellaneous;\n    for (uint256 i = 0; i < _permissions.length; i++) {\n      _ref.permissions.push(_permissions[i]);\n    }\n    return super.deposit(_hub, _from, _to, _amount, _amountOfSwaps, _swapInterval, _owner, _permissions, _miscellaneous);\n  }\n}\n"
    },
    "contracts/DCAHubCompanion/DCAHubCompanion.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport './DCAHubCompanionLibrariesHandler.sol';\nimport './DCAHubCompanionHubProxyHandler.sol';\nimport '../utils/BaseCompanion.sol';\n\ncontract DCAHubCompanion is DCAHubCompanionLibrariesHandler, DCAHubCompanionHubProxyHandler, BaseCompanion, IDCAHubCompanion {\n  constructor(\n    address _swapper,\n    address _allowanceTarget,\n    address _governor,\n    IPermit2 _permit2\n  ) BaseCompanion(_swapper, _allowanceTarget, _governor, _permit2) {}\n}\n"
    },
    "contracts/DCAHubCompanion/DCAHubCompanionLibrariesHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../libraries/InputBuilding.sol';\nimport '../libraries/SecondsUntilNextSwap.sol';\nimport '../interfaces/IDCAHubCompanion.sol';\n\nabstract contract DCAHubCompanionLibrariesHandler is IDCAHubCompanionLibrariesHandler {\n  /// @inheritdoc IDCAHubCompanionLibrariesHandler\n  function getNextSwapInfo(\n    IDCAHub _hub,\n    Pair[] calldata _pairs,\n    bool _calculatePrivilegedAvailability,\n    bytes calldata _oracleData\n  ) external view returns (IDCAHub.SwapInfo memory) {\n    (address[] memory _tokens, IDCAHub.PairIndexes[] memory _indexes) = InputBuilding.buildGetNextSwapInfoInput(_pairs);\n    return _hub.getNextSwapInfo(_tokens, _indexes, _calculatePrivilegedAvailability, _oracleData);\n  }\n\n  /// @inheritdoc IDCAHubCompanionLibrariesHandler\n  function legacyGetNextSwapInfo(ILegacyDCAHub _hub, Pair[] calldata _pairs) external view returns (ILegacyDCAHub.SwapInfo memory) {\n    (address[] memory _tokens, IDCAHub.PairIndexes[] memory _indexes) = InputBuilding.buildGetNextSwapInfoInput(_pairs);\n    return _hub.getNextSwapInfo(_tokens, _indexes);\n  }\n\n  /// @inheritdoc IDCAHubCompanionLibrariesHandler\n  function secondsUntilNextSwap(\n    IDCAHub _hub,\n    Pair[] calldata _pairs,\n    bool _calculatePrivilegedAvailability\n  ) external view returns (uint256[] memory) {\n    return SecondsUntilNextSwap.secondsUntilNextSwap(_hub, _pairs, _calculatePrivilegedAvailability);\n  }\n}\n"
    },
    "contracts/libraries/InputBuilding.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\nimport '../interfaces/ISharedTypes.sol';\n\n/// @title Input Building Library\n/// @notice Provides functions to build input for swap related actions\n/// @dev Please note that these functions are very expensive. Ideally, these would be used for off-chain purposes\nlibrary InputBuilding {\n  /// @notice Takes a list of pairs and returns the input necessary to check the next swap\n  /// @dev Even though this function allows it, the DCAHub will fail if duplicated pairs are used\n  /// @return _tokens A sorted list of all the tokens involved in the swap\n  /// @return _pairsToSwap A sorted list of indexes that represent the pairs involved in the swap\n  function buildGetNextSwapInfoInput(Pair[] calldata _pairs)\n    internal\n    pure\n    returns (address[] memory _tokens, IDCAHub.PairIndexes[] memory _pairsToSwap)\n  {\n    (_tokens, _pairsToSwap, ) = buildSwapInput(_pairs, new IDCAHub.AmountOfToken[](0));\n  }\n\n  /// @notice Takes a list of pairs and a list of tokens to borrow and returns the input necessary to execute a swap\n  /// @dev Even though this function allows it, the DCAHub will fail if duplicated pairs are used\n  /// @return _tokens A sorted list of all the tokens involved in the swap\n  /// @return _pairsToSwap A sorted list of indexes that represent the pairs involved in the swap\n  /// @return _borrow A list of amounts to borrow, based on the sorted token list\n  function buildSwapInput(Pair[] calldata _pairs, IDCAHub.AmountOfToken[] memory _toBorrow)\n    internal\n    pure\n    returns (\n      address[] memory _tokens,\n      IDCAHub.PairIndexes[] memory _pairsToSwap,\n      uint256[] memory _borrow\n    )\n  {\n    _tokens = _calculateUniqueTokens(_pairs, _toBorrow);\n    _pairsToSwap = _calculatePairIndexes(_pairs, _tokens);\n    _borrow = _calculateTokensToBorrow(_toBorrow, _tokens);\n  }\n\n  /// @dev Given a list of token pairs and tokens to borrow, returns a list of all the tokens involved, sorted\n  function _calculateUniqueTokens(Pair[] memory _pairs, IDCAHub.AmountOfToken[] memory _toBorrow)\n    private\n    pure\n    returns (address[] memory _tokens)\n  {\n    uint256 _uniqueTokens;\n    address[] memory _tokensPlaceholder = new address[](_pairs.length * 2 + _toBorrow.length);\n\n    // Load tokens in pairs onto placeholder\n    for (uint256 i; i < _pairs.length; i++) {\n      bool _foundA = false;\n      bool _foundB = false;\n      for (uint256 j; j < _uniqueTokens && !(_foundA && _foundB); j++) {\n        if (!_foundA && _tokensPlaceholder[j] == _pairs[i].tokenA) _foundA = true;\n        if (!_foundB && _tokensPlaceholder[j] == _pairs[i].tokenB) _foundB = true;\n      }\n\n      if (!_foundA) _tokensPlaceholder[_uniqueTokens++] = _pairs[i].tokenA;\n      if (!_foundB) _tokensPlaceholder[_uniqueTokens++] = _pairs[i].tokenB;\n    }\n\n    // Load tokens to borrow onto placeholder\n    for (uint256 i; i < _toBorrow.length; i++) {\n      bool _found = false;\n      for (uint256 j; j < _uniqueTokens && !_found; j++) {\n        if (_tokensPlaceholder[j] == _toBorrow[i].token) _found = true;\n      }\n      if (!_found) _tokensPlaceholder[_uniqueTokens++] = _toBorrow[i].token;\n    }\n\n    // Load sorted into new array\n    _tokens = new address[](_uniqueTokens);\n    for (uint256 i; i < _uniqueTokens; i++) {\n      address _token = _tokensPlaceholder[i];\n\n      // Find index where the token should be\n      uint256 _tokenIndex;\n      while (_tokens[_tokenIndex] < _token && _tokens[_tokenIndex] != address(0)) _tokenIndex++;\n\n      // Move everything one place back\n      for (uint256 j = i; j > _tokenIndex; j--) {\n        _tokens[j] = _tokens[j - 1];\n      }\n\n      // Set token on the correct index\n      _tokens[_tokenIndex] = _token;\n    }\n  }\n\n  /// @dev Given a list of pairs, and a list of sorted tokens, it translates the first list into indexes of the second list. This list of indexes will\n  /// be sorted. For example, if pairs are [{ tokenA, tokenB }, { tokenC, tokenB }] and tokens are: [ tokenA, tokenB, tokenC ], the following is returned\n  /// [ { 0, 1 }, { 1, 1 }, { 1, 2 } ]\n  function _calculatePairIndexes(Pair[] calldata _pairs, address[] memory _tokens)\n    private\n    pure\n    returns (IDCAHub.PairIndexes[] memory _pairIndexes)\n  {\n    _pairIndexes = new IDCAHub.PairIndexes[](_pairs.length);\n    uint256 _count;\n\n    for (uint8 i; i < _tokens.length; i++) {\n      for (uint8 j = i + 1; j < _tokens.length; j++) {\n        for (uint256 k; k < _pairs.length; k++) {\n          if (\n            (_tokens[i] == _pairs[k].tokenA && _tokens[j] == _pairs[k].tokenB) ||\n            (_tokens[i] == _pairs[k].tokenB && _tokens[j] == _pairs[k].tokenA)\n          ) {\n            _pairIndexes[_count++] = IDCAHubSwapHandler.PairIndexes({indexTokenA: i, indexTokenB: j});\n          }\n        }\n      }\n    }\n  }\n\n  /// @dev Given a list of tokens to borrow and a list of sorted tokens, it translated the first list into a list of amounts, sorted by the indexed of\n  /// the seconds list. For example, if `toBorrow` are [{ tokenA, 100 }, { tokenC, 200 }, { tokenB, 500 }] and tokens are [ tokenA, tokenB, tokenC], the\n  /// following is returned [100, 500, 200]\n  function _calculateTokensToBorrow(IDCAHub.AmountOfToken[] memory _toBorrow, address[] memory _tokens)\n    private\n    pure\n    returns (uint256[] memory _borrow)\n  {\n    _borrow = new uint256[](_tokens.length);\n\n    for (uint256 i; i < _toBorrow.length; i++) {\n      uint256 j;\n      while (_tokens[j] != _toBorrow[i].token) j++;\n      _borrow[j] = _toBorrow[i].amount;\n    }\n  }\n}\n"
    },
    "contracts/libraries/SecondsUntilNextSwap.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\nimport '@mean-finance/dca-v2-core/contracts/libraries/TokenSorting.sol';\nimport '@mean-finance/dca-v2-core/contracts/libraries/Intervals.sol';\nimport '../interfaces/ISharedTypes.sol';\n\n/**\n * @title Seconds Until Next Swap Library\n * @notice Provides functions to calculate how long users have to wait until a pair's next swap is available\n */\nlibrary SecondsUntilNextSwap {\n  /**\n   * @notice Returns how many seconds left until the next swap is available for a specific pair\n   * @dev _tokenA and _tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\n   * @param _hub The address of the DCA Hub\n   * @param _tokenA One of the pair's tokens\n   * @param _tokenB The other of the pair's tokens\n   * @param _calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\n   *        the possibility to calculate the seconds until next swap for privileged and non-privileged accounts\n   * @return The amount of seconds until next swap. Returns 0 if a swap can already be executed and max(uint256) if there is nothing to swap\n   */\n  function secondsUntilNextSwap(\n    IDCAHub _hub,\n    address _tokenA,\n    address _tokenB,\n    bool _calculatePrivilegedAvailability\n  ) internal view returns (uint256) {\n    (address __tokenA, address __tokenB) = TokenSorting.sortTokens(_tokenA, _tokenB);\n    bytes1 _activeIntervals = _hub.activeSwapIntervals(__tokenA, __tokenB);\n    bytes1 _mask = 0x01;\n    uint256 _smallerIntervalBlocking;\n    while (_activeIntervals >= _mask && _mask > 0) {\n      if (_activeIntervals & _mask == _mask) {\n        (, uint224 _nextAmountToSwapAToB, uint32 _lastSwappedAt, uint224 _nextAmountToSwapBToA) = _hub.swapData(_tokenA, _tokenB, _mask);\n        uint32 _swapInterval = Intervals.maskToInterval(_mask);\n        uint256 _nextAvailable = ((_lastSwappedAt / _swapInterval) + 1) * _swapInterval;\n        if (!_calculatePrivilegedAvailability) {\n          // If the caller does not have privileges, then they will have to wait a little more to execute swaps\n          _nextAvailable += _swapInterval / 3;\n        }\n        if (_nextAmountToSwapAToB > 0 || _nextAmountToSwapBToA > 0) {\n          if (_nextAvailable <= block.timestamp) {\n            return _smallerIntervalBlocking;\n          } else {\n            return _nextAvailable - block.timestamp;\n          }\n        } else if (_nextAvailable > block.timestamp) {\n          _smallerIntervalBlocking = _smallerIntervalBlocking == 0 ? _nextAvailable - block.timestamp : _smallerIntervalBlocking;\n        }\n      }\n      _mask <<= 1;\n    }\n    return type(uint256).max;\n  }\n\n  /**\n   * @notice Returns how many seconds left until the next swap is available for a list of pairs\n   * @dev Tokens in pairs may be passed in either tokenA/tokenB or tokenB/tokenA order\n   * @param _hub The address of the DCA Hub\n   * @param _pairs Pairs to check\n   * @return _seconds The amount of seconds until next swap for each of the pairs\n   * @param _calculatePrivilegedAvailability Some accounts get privileged availability and can execute swaps before others. This flag provides\n   *        the possibility to calculate the seconds until next swap for privileged and non-privileged accounts\n   */\n  function secondsUntilNextSwap(\n    IDCAHub _hub,\n    Pair[] calldata _pairs,\n    bool _calculatePrivilegedAvailability\n  ) internal view returns (uint256[] memory _seconds) {\n    _seconds = new uint256[](_pairs.length);\n    for (uint256 i; i < _pairs.length; i++) {\n      _seconds[i] = secondsUntilNextSwap(_hub, _pairs[i].tokenA, _pairs[i].tokenB, _calculatePrivilegedAvailability);\n    }\n  }\n}\n"
    },
    "@mean-finance/dca-v2-core/contracts/libraries/TokenSorting.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >0.6;\n\n/// @title TokenSorting library\n/// @notice Provides functions to sort tokens easily\nlibrary TokenSorting {\n  /// @notice Takes two tokens, and returns them sorted\n  /// @param _tokenA One of the tokens\n  /// @param _tokenB The other token\n  /// @return __tokenA The first of the tokens\n  /// @return __tokenB The second of the tokens\n  function sortTokens(address _tokenA, address _tokenB) internal pure returns (address __tokenA, address __tokenB) {\n    (__tokenA, __tokenB) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\n  }\n}\n"
    },
    "@mean-finance/dca-v2-core/contracts/libraries/Intervals.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\n/// @title Intervals library\n/// @notice Provides functions to easily convert from swap intervals to their byte representation and viceversa\nlibrary Intervals {\n  /// @notice Thrown when a user tries convert and invalid interval to a byte representation\n  error InvalidInterval();\n\n  /// @notice Thrown when a user tries convert and invalid byte representation to an interval\n  error InvalidMask();\n\n  /// @notice Takes a swap interval and returns its byte representation\n  /// @dev Will revert with InvalidInterval if the swap interval is not valid\n  /// @param _swapInterval The swap interval\n  /// @return The interval's byte representation\n  function intervalToMask(uint32 _swapInterval) internal pure returns (bytes1) {\n    if (_swapInterval == 1 minutes) return 0x01;\n    if (_swapInterval == 5 minutes) return 0x02;\n    if (_swapInterval == 15 minutes) return 0x04;\n    if (_swapInterval == 30 minutes) return 0x08;\n    if (_swapInterval == 1 hours) return 0x10;\n    if (_swapInterval == 4 hours) return 0x20;\n    if (_swapInterval == 1 days) return 0x40;\n    if (_swapInterval == 1 weeks) return 0x80;\n    revert InvalidInterval();\n  }\n\n  /// @notice Takes a byte representation of a swap interval and returns the swap interval\n  /// @dev Will revert with InvalidMask if the byte representation is not valid\n  /// @param _mask The byte representation\n  /// @return The swap interval\n  function maskToInterval(bytes1 _mask) internal pure returns (uint32) {\n    if (_mask == 0x01) return 1 minutes;\n    if (_mask == 0x02) return 5 minutes;\n    if (_mask == 0x04) return 15 minutes;\n    if (_mask == 0x08) return 30 minutes;\n    if (_mask == 0x10) return 1 hours;\n    if (_mask == 0x20) return 4 hours;\n    if (_mask == 0x40) return 1 days;\n    if (_mask == 0x80) return 1 weeks;\n    revert InvalidMask();\n  }\n\n  /// @notice Takes a byte representation of a set of swap intervals and returns which ones are in the set\n  /// @dev Will always return an array of length 8, with zeros at the end if there are less than 8 intervals\n  /// @param _byte The byte representation\n  /// @return _intervals The swap intervals in the set\n  function intervalsInByte(bytes1 _byte) internal pure returns (uint32[] memory _intervals) {\n    _intervals = new uint32[](8);\n    uint8 _index;\n    bytes1 _mask = 0x01;\n    while (_byte >= _mask && _mask > 0) {\n      if (_byte & _mask != 0) {\n        _intervals[_index++] = maskToInterval(_mask);\n      }\n      _mask <<= 1;\n    }\n  }\n}\n"
    },
    "contracts/mocks/libraries/SecondsUntilNextSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../../libraries/SecondsUntilNextSwap.sol';\n\ncontract SecondsUntilNextSwapMock {\n  function secondsUntilNextSwap(\n    IDCAHub _hub,\n    address _tokenA,\n    address _tokenB,\n    bool _calculatePrivilegedAvailability\n  ) external view returns (uint256) {\n    return SecondsUntilNextSwap.secondsUntilNextSwap(_hub, _tokenA, _tokenB, _calculatePrivilegedAvailability);\n  }\n\n  function secondsUntilNextSwap(\n    IDCAHub _hub,\n    Pair[] calldata _pairs,\n    bool _calculatePrivilegedAvailability\n  ) external view returns (uint256[] memory) {\n    return SecondsUntilNextSwap.secondsUntilNextSwap(_hub, _pairs, _calculatePrivilegedAvailability);\n  }\n}\n"
    },
    "contracts/mocks/libraries/InputBuilding.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../../libraries/InputBuilding.sol';\n\ncontract InputBuildingMock {\n  function buildGetNextSwapInfoInput(Pair[] calldata _pairs)\n    external\n    pure\n    returns (address[] memory _tokens, IDCAHub.PairIndexes[] memory _pairsToSwap)\n  {\n    return InputBuilding.buildGetNextSwapInfoInput(_pairs);\n  }\n\n  function buildSwapInput(Pair[] calldata _pairs, IDCAHub.AmountOfToken[] memory _toBorrow)\n    external\n    pure\n    returns (\n      address[] memory _tokens,\n      IDCAHub.PairIndexes[] memory _pairsToSwap,\n      uint256[] memory _borrow\n    )\n  {\n    return InputBuilding.buildSwapInput(_pairs, _toBorrow);\n  }\n}\n"
    },
    "contracts/libraries/ModifyPositionWithRate.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\n\n/// @title Modify Position With Rate Library\n/// @notice Provides functions modify a position by using rate/amount of swaps\nlibrary ModifyPositionWithRate {\n  /// @notice Modifies the rate of a position. Could request more funds or return deposited funds\n  /// depending on whether the new rate is greater than the previous one.\n  /// @param _hub The address of the DCA Hub\n  /// @param _positionId The position's id\n  /// @param _newRate The new rate to set\n  function modifyRate(\n    IDCAHub _hub,\n    uint256 _positionId,\n    uint120 _newRate\n  ) internal {\n    IDCAHub.UserPosition memory _position = _hub.userPosition(_positionId);\n    if (_newRate != _position.rate) {\n      _modify(_hub, _positionId, _position, _newRate, _position.swapsLeft);\n    }\n  }\n\n  /// @notice Modifies the amount of swaps of a position. Could request more funds or return\n  /// deposited funds depending on whether the new amount of swaps is greater than the swaps left.\n  /// @param _hub The address of the DCA Hub\n  /// @param _positionId The position's id\n  /// @param _newSwaps The new amount of swaps\n  function modifySwaps(\n    IDCAHub _hub,\n    uint256 _positionId,\n    uint32 _newSwaps\n  ) internal {\n    IDCAHub.UserPosition memory _position = _hub.userPosition(_positionId);\n    if (_newSwaps != _position.swapsLeft) {\n      _modify(_hub, _positionId, _position, _position.rate, _newSwaps);\n    }\n  }\n\n  /// @notice Modifies both the rate and amount of swaps of a position. Could request more funds or return\n  /// deposited funds depending on whether the new parameters require more or less than the current unswapped funds.\n  /// @param _hub The address of the DCA Hub\n  /// @param _positionId The position's id\n  /// @param _newRate The new rate to set\n  /// @param _newSwaps The new amount of swaps\n  function modifyRateAndSwaps(\n    IDCAHub _hub,\n    uint256 _positionId,\n    uint120 _newRate,\n    uint32 _newSwaps\n  ) internal {\n    IDCAHub.UserPosition memory _position = _hub.userPosition(_positionId);\n    if (_position.rate != _newRate && _newSwaps != _position.swapsLeft) {\n      _modify(_hub, _positionId, _position, _newRate, _newSwaps);\n    }\n  }\n\n  function _modify(\n    IDCAHub _hub,\n    uint256 _positionId,\n    IDCAHub.UserPosition memory _position,\n    uint120 _newRate,\n    uint32 _newAmountOfSwaps\n  ) private {\n    uint256 _totalNecessary = uint256(_newRate) * _newAmountOfSwaps;\n    if (_totalNecessary >= _position.remaining) {\n      _hub.increasePosition(_positionId, _totalNecessary - _position.remaining, _newAmountOfSwaps);\n    } else {\n      _hub.reducePosition(_positionId, _position.remaining - _totalNecessary, _newAmountOfSwaps, msg.sender);\n    }\n  }\n}\n"
    },
    "contracts/mocks/libraries/ModifyPositionWithRate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../../libraries/ModifyPositionWithRate.sol';\n\ncontract ModifyPositionWithRateMock {\n  function modifyRate(\n    IDCAHub _hub,\n    uint256 _positionId,\n    uint120 _newRate\n  ) external {\n    ModifyPositionWithRate.modifyRate(_hub, _positionId, _newRate);\n  }\n\n  function modifySwaps(\n    IDCAHub _hub,\n    uint256 _positionId,\n    uint32 _newSwaps\n  ) external {\n    ModifyPositionWithRate.modifySwaps(_hub, _positionId, _newSwaps);\n  }\n\n  function modifyRateAndSwaps(\n    IDCAHub _hub,\n    uint256 _positionId,\n    uint120 _newRate,\n    uint32 _newSwaps\n  ) external {\n    ModifyPositionWithRate.modifyRateAndSwaps(_hub, _positionId, _newRate, _newSwaps);\n  }\n}\n"
    },
    "@mean-finance/dca-v2-core/contracts/interfaces/IDCAHubSwapCallee.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport './IDCAHub.sol';\n\n/**\n * @title The interface for handling flash swaps\n * @notice Users that want to execute flash swaps must implement this interface\n */\ninterface IDCAHubSwapCallee {\n  // solhint-disable-next-line func-name-mixedcase\n  function DCAHubSwapCall(\n    address sender,\n    IDCAHub.TokenInSwap[] calldata tokens,\n    uint256[] calldata borrowed,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/DCAHubSwapper/ThirdPartyDCAHubSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/access/IAccessControl.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHubSwapCallee.sol';\n\ncontract ThirdPartyDCAHubSwapper is IDCAHubSwapCallee {\n  /// @notice A target we want to give allowance to\n  struct Allowance {\n    IERC20 token;\n    address spender;\n    uint256 amount;\n  }\n\n  /// @notice The data necessary for a swap to be executed\n  struct SwapExecution {\n    address swapper;\n    uint256 value;\n    bytes swapData;\n  }\n\n  /// @notice Data used for the callback\n  struct SwapWithDexesCallbackData {\n    // If this is a test check\n    bool isTest;\n    // Timestamp where the tx is no longer valid\n    uint256 deadline;\n    // Targets to set allowance to\n    Allowance[] allowanceTargets;\n    // The different swaps to execute\n    SwapExecution[] executions;\n    // A list of tokens to check for unspent balance (should not be reward/to provide)\n    IERC20[] intermediateTokensToCheck;\n    // The address that will receive the unspent tokens\n    address leftoverRecipient;\n  }\n\n  /// @notice An amount of certain token\n  struct AmountOfToken {\n    address token;\n    uint256 amount;\n  }\n\n  /// @notice Thrown when the swap is a test. It reports the amount of tokens help by the swapper\n  error SwapResults(AmountOfToken[] amounts);\n\n  /// @notice Thrown when deadline has passed\n  error TransactionTooOld();\n\n  /// @notice Thrown when the caller tries to execute a swap, but they are not the privileged swapper\n  error NotPrivilegedSwapper();\n\n  using SafeERC20 for IERC20;\n  using Address for address;\n\n  bytes32 public constant PRIVILEGED_SWAPPER_ROLE = keccak256('PRIVILEGED_SWAPPER_ROLE');\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DCAHubSwapCall(\n    address,\n    IDCAHub.TokenInSwap[] calldata _tokens,\n    uint256[] calldata,\n    bytes calldata _data\n  ) external {\n    SwapWithDexesCallbackData memory _callbackData = abi.decode(_data, (SwapWithDexesCallbackData));\n    if (block.timestamp > _callbackData.deadline) revert TransactionTooOld();\n    _approveAllowances(_callbackData.allowanceTargets);\n    _executeSwaps(_callbackData.executions);\n    if (_callbackData.isTest) {\n      _revertWithResults(_tokens, _callbackData.intermediateTokensToCheck);\n    }\n    _handleSwapTokens(_tokens, _callbackData.leftoverRecipient);\n    _handleIntermediateTokens(_callbackData.intermediateTokensToCheck, _callbackData.leftoverRecipient);\n  }\n\n  /**\n   * @notice Executed a DCA swap\n   * @dev There are some cases where the oracles differ from what the markets can offer, so a swap can't be executed. But\n   *      it could happen that even if the amounts being swap are really big, the difference between oracle and market is\n   *      only a few dollars. In that case, it would be nice if someone could just pay for the difference.\n   *      The idea here is that instead of calling the hub directly, someone could call the swapper with some native token,\n   *      so that when the swapper gets called, they can use that native token balance as part of the swap, and cover the\n   *      difference\n   */\n  function executeSwap(\n    IDCAHubWithAccessControl _hub,\n    address[] calldata _tokens,\n    IDCAHub.PairIndexes[] calldata _pairsToSwap,\n    uint256[] calldata _borrow,\n    bytes calldata _callbackData,\n    bytes calldata _oracleData\n  ) external payable {\n    if (!_hub.hasRole(PRIVILEGED_SWAPPER_ROLE, msg.sender)) {\n      revert NotPrivilegedSwapper();\n    }\n    _hub.swap(_tokens, _pairsToSwap, address(this), address(this), _borrow, _callbackData, _oracleData);\n  }\n\n  function _approveAllowances(Allowance[] memory _allowanceTargets) internal {\n    for (uint256 i = 0; i < _allowanceTargets.length; ) {\n      Allowance memory _target = _allowanceTargets[i];\n      uint256 _currentAllowance = _target.token.allowance(address(this), _target.spender);\n      if (_currentAllowance < _target.amount) {\n        if (_currentAllowance > 0) {\n          _target.token.approve(_target.spender, 0); // We do this because some tokens (like USDT) fail if we don't\n        }\n        _target.token.approve(_target.spender, type(uint256).max);\n      }\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function _executeSwaps(SwapExecution[] memory _executions) internal {\n    for (uint256 i = 0; i < _executions.length; ) {\n      SwapExecution memory _execution = _executions[i];\n      _execution.swapper.functionCallWithValue(_execution.swapData, _execution.value, 'Call to swapper failed');\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function _handleSwapTokens(IDCAHub.TokenInSwap[] calldata _tokens, address _leftoverRecipient) internal {\n    for (uint256 i = 0; i < _tokens.length; ) {\n      IERC20 _token = IERC20(_tokens[i].token);\n      uint256 _balance = _token.balanceOf(address(this));\n      if (_balance > 0) {\n        uint256 _toProvide = _tokens[i].toProvide;\n        if (_toProvide > 0) {\n          // Send everything to hub (we assume the hub is msg.sender)\n          _token.safeTransfer(msg.sender, _balance);\n        } else {\n          // Send reward to the leftover recipient\n          _token.safeTransfer(_leftoverRecipient, _balance);\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function _handleIntermediateTokens(IERC20[] memory _intermediateTokens, address _leftoverRecipient) internal {\n    for (uint256 i = 0; i < _intermediateTokens.length; ) {\n      uint256 _balance = _intermediateTokens[i].balanceOf(address(this));\n      if (_balance > 0) {\n        _intermediateTokens[i].safeTransfer(_leftoverRecipient, _balance);\n      }\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function _revertWithResults(IDCAHub.TokenInSwap[] calldata _tokens, IERC20[] memory _intermediateTokens) internal view {\n    AmountOfToken[] memory _amounts = new AmountOfToken[](_tokens.length + _intermediateTokens.length);\n    for (uint256 i; i < _tokens.length; i++) {\n      address _token = _tokens[i].token;\n      _amounts[i] = AmountOfToken({token: _token, amount: IERC20(_token).balanceOf(address(this))});\n    }\n    for (uint256 i; i < _intermediateTokens.length; i++) {\n      _amounts[i + _tokens.length] = AmountOfToken({\n        token: address(_intermediateTokens[i]),\n        amount: _intermediateTokens[i].balanceOf(address(this))\n      });\n    }\n    revert SwapResults(_amounts);\n  }\n}\n\ninterface IDCAHubWithAccessControl is IDCAHub, IAccessControl {}\n"
    },
    "contracts/mocks/LegacyDCASwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '../interfaces/ILegacyDCAHub.sol';\n\ncontract LegacyDCASwapper {\n  using SafeERC20 for IERC20;\n  address internal _swapExecutor;\n\n  function swapForCaller(\n    ILegacyDCAHub _hub,\n    address[] calldata _tokens,\n    IDCAHub.PairIndexes[] calldata _pairsToSwap,\n    address _recipient\n  ) external {\n    // Set the executor\n    _swapExecutor = msg.sender;\n\n    // Execute swap\n    _hub.swap(_tokens, _pairsToSwap, _recipient, address(this), new uint256[](_tokens.length), '');\n\n    // Clear the swap executor\n    _swapExecutor = address(0);\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DCAHubSwapCall(\n    address,\n    IDCAHub.TokenInSwap[] calldata _tokens,\n    uint256[] calldata,\n    bytes calldata\n  ) external {\n    address _swapExecutorMem = _swapExecutor;\n    for (uint256 i = 0; i < _tokens.length; ) {\n      IDCAHub.TokenInSwap memory _token = _tokens[i];\n      if (_token.toProvide > 0) {\n        // We assume that msg.sender is the DCAHub\n        IERC20(_token.token).safeTransferFrom(_swapExecutorMem, msg.sender, _token.toProvide);\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  function _handleSwapForCallerCallback(IDCAHub.TokenInSwap[] calldata _tokens) internal {\n    // Load to mem to avoid reading storage multiple times\n    address _swapExecutorMem = _swapExecutor;\n    for (uint256 i = 0; i < _tokens.length; ) {\n      IDCAHub.TokenInSwap memory _token = _tokens[i];\n      if (_token.toProvide > 0) {\n        // We assume that msg.sender is the DCAHub\n        IERC20(_token.token).safeTransferFrom(_swapExecutorMem, msg.sender, _token.toProvide);\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n}\n"
    },
    "contracts/DCAHubSwapper/CallerOnlyDCAHubSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '../interfaces/ICallerOnlyDCAHubSwapper.sol';\nimport './utils/DeadlineValidation.sol';\n\ncontract CallerOnlyDCAHubSwapper is DeadlineValidation, ICallerOnlyDCAHubSwapper {\n  using SafeERC20 for IERC20;\n  using Address for address;\n\n  /// @notice Thrown when the caller tries to execute a swap, but they are not the privileged swapper\n  error NotPrivilegedSwapper();\n\n  bytes32 public constant PRIVILEGED_SWAPPER_ROLE = keccak256('PRIVILEGED_SWAPPER_ROLE');\n\n  /// @notice Represents the lack of an executor. We are not using the zero address so that it's cheaper to modify\n  address internal constant _NO_EXECUTOR = 0x000000000000000000000000000000000000dEaD;\n  /// @notice The caller who initiated a swap execution\n  address internal _swapExecutor = _NO_EXECUTOR;\n\n  /// @inheritdoc ICallerOnlyDCAHubSwapper\n  function swapForCaller(SwapForCallerParams calldata _parameters)\n    external\n    payable\n    checkDeadline(_parameters.deadline)\n    returns (IDCAHub.SwapInfo memory _swapInfo)\n  {\n    if (!_parameters.hub.hasRole(PRIVILEGED_SWAPPER_ROLE, msg.sender)) {\n      revert NotPrivilegedSwapper();\n    }\n\n    // Set the swap's executor\n    _swapExecutor = msg.sender;\n\n    // Execute swap\n    _swapInfo = _parameters.hub.swap(\n      _parameters.tokens,\n      _parameters.pairsToSwap,\n      _parameters.recipient,\n      address(this),\n      new uint256[](_parameters.tokens.length),\n      '',\n      _parameters.oracleData\n    );\n\n    // Check that limits were met\n    for (uint256 i = 0; i < _swapInfo.tokens.length; ) {\n      IDCAHub.TokenInSwap memory _tokenInSwap = _swapInfo.tokens[i];\n      if (_tokenInSwap.reward < _parameters.minimumOutput[i]) {\n        revert RewardNotEnough();\n      } else if (_tokenInSwap.toProvide > _parameters.maximumInput[i]) {\n        revert ToProvideIsTooMuch();\n      }\n      unchecked {\n        i++;\n      }\n    }\n\n    // Clear the swap executor\n    _swapExecutor = _NO_EXECUTOR;\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DCAHubSwapCall(\n    address,\n    IDCAHub.TokenInSwap[] calldata _tokens,\n    uint256[] calldata,\n    bytes calldata\n  ) external {\n    // Load to mem to avoid reading storage multiple times\n    address _swapExecutorMem = _swapExecutor;\n    for (uint256 i = 0; i < _tokens.length; ) {\n      IDCAHub.TokenInSwap memory _token = _tokens[i];\n      if (_token.toProvide > 0) {\n        // We assume that msg.sender is the DCAHub\n        IERC20(_token.token).safeTransferFrom(_swapExecutorMem, msg.sender, _token.toProvide);\n      }\n      unchecked {\n        i++;\n      }\n    }\n  }\n}\n"
    },
    "contracts/interfaces/ICallerOnlyDCAHubSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nimport '@openzeppelin/contracts/access/IAccessControl.sol';\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHub.sol';\nimport '@mean-finance/dca-v2-core/contracts/interfaces/IDCAHubSwapCallee.sol';\n\ninterface ICallerOnlyDCAHubSwapper is IDCAHubSwapCallee {\n  /// @notice Parameters to execute a swap for caller\n  struct SwapForCallerParams {\n    // The address of the DCAHub\n    IDCAHubWithAccessControl hub;\n    // The tokens involved in the swap\n    address[] tokens;\n    // The pairs to swap\n    IDCAHub.PairIndexes[] pairsToSwap;\n    // Bytes to send to the oracle when executing a quote\n    bytes oracleData;\n    // The minimum amount of tokens to receive as part of the swap\n    uint256[] minimumOutput;\n    // The maximum amount of tokens to provide as part of the swap\n    uint256[] maximumInput;\n    // Address that will receive all the tokens from the swap\n    address recipient;\n    // Deadline when the swap becomes invalid\n    uint256 deadline;\n  }\n\n  /// @notice Thrown when the reward is less that the specified minimum\n  error RewardNotEnough();\n\n  /// @notice Thrown when the amount to provide is more than the specified maximum\n  error ToProvideIsTooMuch();\n\n  /**\n   * @notice Executes a swap for the caller, by sending them the reward, and taking from them the needed tokens\n   * @dev Can only be called by user with appropriate role\n   *      Will revert:\n   *      - With RewardNotEnough if the minimum output is not met\n   *      - With ToProvideIsTooMuch if the hub swap requires more than the given maximum input\n   * @return The information about the executed swap\n   */\n  function swapForCaller(SwapForCallerParams calldata parameters) external payable returns (IDCAHub.SwapInfo memory);\n}\n\ninterface IDCAHubWithAccessControl is IDCAHub, IAccessControl {}\n"
    },
    "contracts/DCAHubSwapper/utils/DeadlineValidation.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.7 <0.9.0;\n\nabstract contract DeadlineValidation {\n  modifier checkDeadline(uint256 deadline) {\n    require(_blockTimestamp() <= deadline, 'Transaction too old');\n    _;\n  }\n\n  /// @dev Method that exists purely to be overridden for tests\n  /// @return The current block timestamp\n  function _blockTimestamp() internal view virtual returns (uint256) {\n    return block.timestamp;\n  }\n}\n"
    },
    "contracts/mocks/DCAHubSwapper/CallerOnlyDCAHubSwapper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.7 <0.9.0;\n\nimport '../../DCAHubSwapper/CallerOnlyDCAHubSwapper.sol';\n\ncontract CallerOnlyDCAHubSwapperMock is CallerOnlyDCAHubSwapper {\n  function isSwapExecutorEmpty() external view returns (bool) {\n    return _swapExecutor == _NO_EXECUTOR;\n  }\n\n  function setSwapExecutor(address _newSwapExecutor) external {\n    _swapExecutor = _newSwapExecutor;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}